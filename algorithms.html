<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FOR JAVA JUNIOR</title>
    
    <link rel="stylesheet" href="style.css">

</head>

<body>

   <header>
        <h1>JAVA-DEV</h1>
   </header>

   <nav class="mainNav">
       <a href="#">ООП</a>
       <a href="#">SOLID</a>
       <a href="datastructures.html">Data&#160;structures</a>
       <a href="#algorithms.html">Алгоритмы</a>
       <a href="home.html">JAVA&#160;Core</a>
       <a href="#">STREAM&#160;API</a>
       <a href="junit.html">JUnit</a>
       <br>
       <a href="sql.html">SQL</a>
       <a href="#">HTML5</a>
       <a href="#">Jsoup</a>
       <a href="#">CSS</a>
       <a href="#">JS</a>
       <a href="json.html">JSON</a>
       <a href="maven.html">MAVEN</a>
       <a href="git.html">Git</a>
       <br>
       <a href="#">Spring&#160;Framework</a>
       <a href="#">Hibernate</a>
       <a href="#">Docker</a>
       <a href="#">Хэширование</a>
       <a href="#">Patterns</a>
       <a href="#">Микросервисная&#160;архитектура</a>
   </nav>

   <div class="hero">
       <h1>JAVA-DEVOLOPMENT FOR JUNIOR</h1>
       <p>Эта страница создана для помощи в подготовке Junior-разработчика.</p>
       <p>Исключительно для личного пользования.</p>
   </div>

  
    <div class="content">
        <div>
            <p>Рекомендации:
                <br><span>Роберт Седжвик «Java Algorithms»</span>
                <br>
                <a href="https://www.examclouds.com/ru/java/java-core-russian/sorting-algoritms" style="color: blanchedalmond;">
                    Видеоуроки по реализации ключевых алгоритмов в Java</a>
            </p>
        </div>

        <div>
            <p><br>В программировании алгоритм — это набор инструкций, последовательность действий для решения конкретной проблемы 
                или достижения конкретной задачи. Она может быть простой. Пример – добавление двух чисел. Могут быть сложные «первоначальные задачи» 
                — преобразование видеоформата из одного в другой.
                Алгоритмы могут быть написаны на любом языке программирования и могут быть как простыми (последовательность основных операций), 
                так и сложными (многоэтапный процесс, включающий различные структуры данных и логику). 
                Основная цель алгоритма — принять входные данные, обработать их и предоставить ожидаемый результат.</p>
        </div>

        <div>
            <br><h2>Оценка сложности алгоритмов Big O</h2>
            <p>Сложность алгоритмов оценивают по времени выполнения задачи или по используемой памяти.
            <br>Сложность зависит от размеров входных данных: <br>массив из 100 элементов будет обработан быстрее, чем аналогичный из 1000.
            <br>Big O показывает верхнюю границу (худший вариант) того, как сложность алгоритма растёт с увеличением входных данных.
            <br><br>Сложность алгоритма может быть:
            <br><br>О(1) – константная сложность
            <br>Например: получить элемент массива по индексу
            <br><br>O(log n) – логарифмическая сложность
            <br>Сложность алгоритма растёт логарифмически с увеличением входных данных.
            <br>Например: на каждой итерации берется половина элементов – бинарный поиск
            <br><br>О(n) – линейная сложность
            <br>Сложность алгоритма растёт линейно с увеличением входных данных.
            <br>Например: цикл по всем элементам массива, рекурсивная функция
            <br><br>O(n&#178;) – квадратичная сложность
            <br>Например: вложенный цикл
            <br><br>При оценке сложности константы не играют роли – отбрасываем константы и берем только наибольшую сложность.
            <br>Неважная сложность и отбрасывание констант:
            <br><br>O(n&#178; + n&#178;) = O(n&#178;)
            <br><br>O(n&#178; + n) = O(n&#178;)
            <br><br>O(n + log n) = O(n) - Сложность log n меньше чем n
            <br><br>O(2 * 2<sup>n</sup> + 22 * n&#178;) = O(2<sup>n</sup>) - Отбрасываем константы 2 и 22, оставляем наибольшую сложность: 2n гораздо больше n&#178;
            <br><br>O(n&#178; + m) = O(n&#178; + m) - Выражение не может быть упрощено т.к. мы ничего не знаем про m.
            </p>
        </div>

        <div>
            <br><h2>N алгоритмов, которые должен знать начинающий разработчик :</h2>

            <br><h3>&#10003; Линейный поиск</h3>
            <p>
                <br>Линейный или последовательный поиск – простейший алгоритм поиска. 
                <br>Он редко используется из-за своей неэффективности. По сути, это метод полного перебора, и он уступает другим алгоритмам.
                <br>У линейного поиска нет предварительных условий к состоянию структуры данных.
                Алгоритм ищет элемент в заданной структуре данных, пока не достигнет конца структуры.
                При нахождении элемента возвращается его позиция в структуре данных. Если элемент не найден, возвращаем -1.
                <br><br>
                <pre>

                    public static int linearSearch(int arr[], int elementToSearch) {
                        for (int index = 0; index < arr.length; index++) {
                            if (arr[index] == elementToSearch)
                                return index;
                        }
                        return -1;
                    }
                </pre>

                <br>Временная сложность:
                <br>Для получения позиции искомого элемента перебирается набор из N элементов. 
                В худшем сценарии для этого алгоритма искомый элемент оказывается последним в массиве.
                В этом случае потребуется N итераций для нахождения элемента.
                Следовательно, временная сложность линейного поиска равна O(N).
                <br>Пространственная сложность:
                <br>Этот поиск требует всего одну единицу памяти для хранения искомого элемента. Это не относится к размеру входного массива.
                Следовательно, пространственная сложность линейного поиска равна O(1).
                <br><br>Применение:
                <br>Линейный поиск можно использовать для малого, несортированного набора данных, который не увеличивается в размерах.
                Несмотря на простоту, алгоритм не находит применения в проектах из-за линейного увеличения временной сложности.
            </p>

            <br><h3>&#10003; Бинарный поиск</h3>
            <p><br>Бинарный поиск – это одна из первых вещей, 
                с которыми сталкиваются в начале изучения computer science. 
                Это возможно самый простой пример того, как немного изобретательности может сделать решения, в буквальном смысле, 
                экспоненциально более эффективными. <br>Его суть в том, что нам дан отсортированный массив. 
                Необходимо итеративно делить его пополам, брать значение в середине и сравнивать его с элементом, который хотим найти: 
                если он больше – ищем в правой половине, если меньше – в левой. 
                И так до тех пор, пока элемент не будет найден.
            </p>

            <br><h3>&#10003; Сортировки пузырьком, выбором, вставками</h3>
            <p>
                <br>Алгоритмы сортировки – один из фундаментальных инструментов, которые разработчик должен иметь в своем арсенале. 
                <br>Квадратичные сортировки (пузырьком, выбором, вставками) – первое, что следует проработать начинающему разработчику. 
                В случае когда скорость имеет значение, вы вряд ли будете их использовать, 
                но работа с ними является хорошим введением в работу с массивами.

                <br><br><b>Сортировка пузырьком:</b>
                <br>Пузырьковая сортировка - это учебная сортировка, у которой существует множество модификаций.
                <br>Идея пузырьковой сортировки: шаг сортировки состоит в проходе снизу вверх по массиву. 
                По пути просматриваются пары соседних элементов. 
                Если элементы некоторой пары находятся в неправильном порядке, то меняем их местами.
                <br>В результате нулевого прохода минимальный элемент "всплывает" вверх - отсюда и название алгоритма - сортировка пузырьком. 
                <br>Повторяем алгоритм для всех элементов, кроме нулевого - он уже находится на своем месте. 
                И находим второй по величине элемент. Повторяем алгоритм, пока элементы не будут отсортированы. 
                <br> Cортировки пузырьком на Java.
                <br>Внешний цикл for отвечает за номер прохода, а внутренний - за перебор элементов в одном проходе. 
                <br>Обмен значений производится с помощью временной переменной tmp.
                <br>Во внутреннем цикле перебираем значения начиная с последнего (array.length - 1) 
                и в каждом следующем проходе уменьшаем количество просмотренных элементов (j > i).
                <br><br>
                <pre>

                    public class BubbleSorter {
                        public static void sort(int[] array) { // i - номер прохода
                            for (int i = 0; i < array.length - 1; i++) {
                                // внутренний цикл прохода
                                for (int j = array.length - 1; j > i; j--) {
                                    if (array[j - 1] > array[j]) {
                                        int tmp = array[j - 1];
                                        array[j - 1] = array[j];
                                        array[j] = tmp;
                                    }
                                }
                            }
                        }
                    }
                </pre>

                <br><br><b>Сортировка выбором:</b>
                <br>ищем минимальный элемент в массиве и меняем его местами с элементом, находящимся в позиции ноль. 
                Далее ищем следующий по величине элемент и меняем его с элементом с индексом 1 и так далее.
                <br>Рассмотрим реализацию алгоритма. 
                <br>Внешний цикл for отвечает за номер прохода, а внутренний - за поиск минимального значения в текущем проходе. 
                Обратите внимание, что во внутреннем цикле начинаем искать минимальный элемент не с самого начала, 
                а пропускаем уже найденные на предыдущем шаге элементы:
                <br><br>
                <pre>

                    public class SelectionSorter {
                        public static void sort(int[] array) {
                            for (int i = 0; i < array.length; i++) {    // i - номер текущего шага
                                int pos = i;
                                int min = array[i];
                                // цикл выбора наименьшего элемента
                                for (int j = i + 1; j < array.length; j++) {
                                    if (array[j] < min) {
                                        pos = j;    // pos - индекс наименьшего элемента
                                        min = array[j];
                                    }
                                }
                                array[pos] = array[i];
                                array[i] = min;    // меняем местами наименьший с array[i]
                            }
                        }
                    }
                </pre>
            </p>

            <br><h3>&#10003; Быстрая сортировка, сортировка слиянием и пирамидальная сортировка</h3>
            <p><br>Как было сказано выше, алгоритмы сортировки отлично подходят, чтобы научиться чувствовать себя комфортно при работе с массивами, 
                но быстрая сортировка и сортировка слиянием достаточно эффективны, чтобы использоваться в реальных приложениях. 
                Умение с легкостью реализовывать их (Заметьте: «с легкостью реализовывать», а не зазубривать) необходимо каждому продвинутому разработчику.

                <br><br><b>Быстрая сортировка:</b><br>Быстрая сортировка — это алгоритм «разделяй и властвуй», 
                который выбирает «основной» элемент из массива и разбивает остальные элементы на два подмассива. 
                Затем подмассивы сортируются рекурсивно.
            
                <br><br><b>Сортировка слиянием:</b> <br>Алгоритм сортировки слиянием — это алгоритм «разделяй и властвуй», 
                который делит массив на две части, сортирует две половины, а затем снова объединяет их.
            
                <br><br><b>Пирамидальная сортировка:</b><br>Пирамидальная сортировка — это алгоритм сортировки на основе сравнения, 
                который строит пирамиду из входных элементов, а затем многократно извлекает её максимальный элемент и помещает его в конец 
                отсортированного выходного массива.  
            </p>

            <br><h3>&#10003; Хеш-таблицы</h3>
            <p>
                <br> Хэш-таблица — это структура данных, которая сопоставляет ключи со значениями, 
                используя хеш-функцию для вычисления индекса в массиве сегментов или слотов, из которых можно найти желаемое значение.
            </p>

            <br><h3>&#10003; Кодирование Хаффмена</h3>
            <p>
                <br>Кодирование Хаффмена – это основа современного сжатия текстов. 
                Суть его заключается в анализе частотности появления символов в тексте и построения на его основе дерева из этих символов.
                Уделение времени разбору как работает кодирование Хаффмана – это хороший способ освоиться в работе с представлением данных и обходом деревьев, 
                что является двумя наиболее важными проблемными вопросами, с которыми приходится сталкиваться специалистам по Computer Science.
            </p>

            <br><h3>&#10003; Поиск в ширину</h3>
            <p>
                <br>Деревья лежат в основе множества алгоритмов и программ, с которыми имеет дело разработчик. 
                Поэтому базовое понимание идеи обхода деревьев – один из наивысших приоритетов для начинающего разработчика.
                В поиске в ширину мы исследуем дерево уровень за уровнем, и так до тех пор, пока не найдем искомый узел. 
                Прохождение через каждый уровень гарантирует нахождение решения.
            </p>

            <br><h3>&#10003; Поиск в глубину</h3>
            <p>
                <br>Поиск в глубину является вторым основным подходом нахождения элемента в дереве. 
                Вместо обхода дерева поуровнево, он исследует дерево ветка за веткой.
                При отсутствии у дерева не бесконечно распространяющихся ветвей, поиск в глубину также будет работать безотказно. 
                Реализация этих двух алгоритмов не очень сложна, но важно понимать, когда использовать один алгоритм, а когда другой. 
                При создании архитектуры программы огромное значение имеет понимание структуры информации, с которой вы работаете, 
                и выбор оптимального для нее алгоритма.
            </p>

            <br><h3>&#10003; Градиентный спуск</h3>
            <p>
                <br>Для большинства разработчиков этот алгоритм не имеет широкого применения. 
                Однако в случаях регрессии или машинного обучения он становится фундаментом для всей вашей работы.
                Градиентный спуск – это способ оптимизации функций, основанный на вычислениях. 
                В контексте машинного обучения или регрессии это значит нахождение значений весов алгоритма ML, 
                минимизирующих ошибку в предсказаниях. И хотя математически он более сложен, чем остальные алгоритмы, 
                при работе с данными и предсказаниями понимание его работы имеет огромное значение.
            </p>

            <br><h3>&#10003; Алгоритм Дейкстры</h3>
            <p>
                <br>Еще одна невероятно важная задача, с которой сталкиваются разработчики, это поиск путей. 
                Графы невероятно эффективны для описания всех видов задач, включающих сеть связей отдельных объектов.
                Алгоритм Дейкстры – это способ поиска кратчайшего пути между узлами в графе. 
                Он является базой в задачах поиска пути и находит широкое применение начиная с искусственного интеллекта и заканчивая созданием игр.
            </p>

            <br><h3>&#10003; Обмен ключами Диффи-Хеллмана</h3>
            <p>
                <br>Обмен ключами Диффи-Хеллмана – это отличное введение в криптографию. 
                Если конкретизировать, то он работает путем объединения открытых и закрытых ключей (которые представляют из себя очень длинные числа) 
                для шифрования информации, передаваемой между двумя различными сторонами.
                Даже если вы не работаете в кибербезопасности, понимание криптографии и принципов защищенной связи очень важно для работы разработчика. 
                И хотя Диффи-Хеллман далеко не идеален, он очень прост в реализации и похож на большинство других методов зашифрованной связи. 
            </p>
        </div>

    </div>

   <footer>
    &copy; 2023 Creative Java cheat sheet :: algorithms
   </footer>
  
</body>
</html>