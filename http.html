<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>index</title>

    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>JAVA-DEV</h1>
   </header>

   <nav class="mainNav">
    <a href="#">ООП</a>
    <a href="#">SOLID</a>
    <a href="datastructures.html">Data&#160;structures</a>
    <a href="algorithms.html">Алгоритмы</a>
    <a href="home.html">JAVA&#160;Core</a>
    <a href="#">STREAM&#160;API</a>
    <a href="junit.html">JUnit</a>
    <br>
    <a href="#">HTML5</a>
    <a href="#">Jsoup</a>
    <a href="#">CSS</a>
    <a href="#">JS</a>
    <a href="json.html">JSON</a>
    <a href="http.html">HTTP</a>
    <br>
    <a href="sql.html">SQL</a>
    <a href="maven.html">MAVEN</a>
    <a href="git.html">Git</a>
    <br>
    <a href="spring.html">SPRING</a>
    <a href="#">Docker</a>
    <a href="#">Хэширование</a>
    <a href="#">Patterns</a>
    <a href="#">Микросервисная&#160;архитектура</a>
</nav>

   <div class="hero">
       <h1>JAVA-DEVOLOPMENT FOR JUNIOR</h1>
       <p>Эта страница создана для помощи в подготовке Junior-разработчика.</p>
       <p>Исключительно для личного пользования.</p>
   </div>

  
    <div class="content">

        <p>
            HTTP — широко распространённый протокол передачи данных, изначально предназначенный для передачи гипертекстовых документов 
            (то есть документов, которые могут содержать ссылки, позволяющие организовать переход к другим документам).

            <br><br>Аббревиатура HTTP расшифровывается как <i>HyperText Transfer Protocol</i>, «протокол передачи гипертекста». 

            <br><br>Протокол HTTP предполагает использование клиент-серверной структуры передачи данных. Клиентское приложение формирует запрос и отправляет 
            его на сервер, после чего серверное программное обеспечение обрабатывает данный запрос, формирует ответ и передаёт его обратно клиенту. 
            После этого клиентское приложение может продолжить отправлять другие запросы, которые будут обработаны аналогичным образом.

            <br><br>Задача, которая традиционно решается с помощью протокола HTTP — обмен данными между пользовательским приложением,
            осуществляющим доступ к веб-ресурсам (обычно это веб-браузер) и веб-сервером.

            <br>Также HTTP часто используется как протокол передачи информации для других протоколов прикладного уровня, таких как SOAP, XML-RPC и WebDAV. 
            В таком случае говорят, что протокол HTTP используется как «транспорт».

            <br>API многих программных продуктов также подразумевает использование HTTP для передачи данных — сами данные при этом могут иметь любой формат, 
            например, XML или JSON.

            <br><br>Как правило, передача данных по протоколу HTTP осуществляется через TCP/IP-соединения. 
            Серверное программное обеспечение при этом обычно использует TCP-порт 80 (и, если порт не указан явно, 
            то обычно клиентское программное обеспечение по умолчанию использует именно 80-й порт для открываемых HTTP-соединений), 
            хотя может использовать и любой другой.
        </p>

        <p>
            На подавляющем большинстве сайтов, если обратить внимание на URL, можно заметить, что указан не протокол HTTP, а <b>HTTPS</b>. 
            <br>Буква S в конце наименования протокола означает "secure" и, по сути, является надстройкой безопасности к данному протоколу.

            <br><br>С 2015 года под буквой S подразумевается протокол шифрования TLS. До 2015 года использовался протокол шифрования SSL. 
            Следует помнить, что <i>для ресурсов, использующих протокол HTTP, по умолчанию используется порт 80, а для протокола HTTPS – порт 443.</i>

            <br><br>По сути, протокол TLS выполняет следующие функции:

            <br><br><b>Шифрование</b> - передача информации происходит в зашифрованном виде, что делает невозможной кражу информации и отслеживание действий пользователя на других ресурсах.
            <br><b>Аутентификация</b> - пользователю гарантируется, что он переходит на официальный сайт, а не на его дубликат.
            <br><b>Сохранение данных</b> - в случае попытки злоумышленника взломать систему, информация об этом сохраняется.
        </p>

        <p>
            <u><h3>Версии HTTP</h3></u>
            Стандарт <b>HTTP/0.9</b>
            <br>Стандарт <b>HTTP/1.0</b>
            <br>Стандарт <b>HTTP/1.1</b> - активно используется в настоящее время.
            <br>Стандарт <b>HTTP/2.0</b> - многие новые проекты переходят на эту версию. Технологии, такие как GraphQL и gRPC, 
            часто работают на этой версии протокола HTTP.
            <br>Также существует экспериментальная версия <b>HTTP/3.0</b>, которая является наследницей HTTP/2.0. 
            Особенность этой версии заключается в использовании экспериментального протокола QUIC. QUIC, в свою очередь, 
            является надстройкой к протоколу транспортного уровня UDP. QUIC делает UDP более безопасным, но при этом он все равно работает быстрее, чем TCP.
            
            <u><h3>Методы HTTP</h3></u>
            HTTP поддерживает 9 методов запросов, каждый из которых выполняет определенную функцию:
            <br>
            <br><b>GET</b> - запрос информации о ресурсе.
            <br><b>POST</b> - запрос на создание ресурса (например, регистрация пользователя).
            <br><b>PUT</b> - запрос на обновление ресурса (обновляет ресурс полностью).
            <br><b>PATCH</b> - запрос на обновление ресурса (частично обновляет ресурс).
            <br><b>DELETE</b> - запрос на удаление ресурса.
            <br><b>OPTIONS</b> - запрос информации о поддерживаемых методах у ресурса (в заголовке Allow представляются поддерживаемые методы).
            <br><b>HEAD</b> - запрос заголовков ресурса (аналогичен методу GET, но без получения тела ответа).
            <br><b>CONNECT</b> - преобразование соединения в прозрачный TCP/IP-туннель, например, для соединения с сайтом через SSL.
            <br><b>TRACE</b> - позволяет клиенту видеть, что происходит на каждом этапе между клиентом и сервером.
            <br><br>На практике чаще всего используются первые пять методов HTTP (<i>GET, POST, PUT, PATCH, DELETE</i>) для реализации так называемого акронима <b>CRUD</b> (<i>Create, Read, Update, Delete</i>). 
            <br>В его рамках:
            
            <br><br>Метод GET реализует букву R (Read - читать).
            <br>Метод POST реализует букву C (Create - создавать).
            <br>Методы PUT и PATCH реализуют букву U (Update - обновлять).
            <br>Метод DELETE реализует букву D (Delete - удалять).

            <br><br>На собеседовании могут спросить: "Какие методы, кроме основных, Вы знаете?". Достаточно упомянуть методы HEAD и OPTIONS и понимать, 
            какую информацию они предоставляют.
        </p>
        <p><b>*</b></p>
        <p>
            <img src="images/http0.jpg"></img>
            <br>URI - состоящий из полного пути к ресурсу, является абсолютным URI. На примере с картинкой, URL + Endpoint - является абсолютным URI
            <br>На примере с картинкой, относительным URI является например - /watch?v=e_atyw0IDqg или https://www.youtube.com
        </p>

        <p>
            <u><h3>HTTP Request</h3></u>
            <b>Request</b> — это отправляемый запрос на сервер. Request состоит из следующих частей:

            <ol>
                <li>
                    <b>Стартовая строка</b>, в которой указывается:
                    <ul>
                        <li>Протокол и версия протокола</li>
                        <li>Метод запроса</li>
                        <li>URI</li>
                    </ul>
                </li>
                <li><b>Request headers</b> — заголовки со служебной, уточняющей и дополнительной информацией в формате "ключ: значение".</li>
                <li><b>Request body</b> — тело запроса, в котором передаются необходимые данные для внесения изменений в БД.</li>
            </ol>
            <i>Опционально:</i>
            <br><b>Query</b>-параметры могут передаваться в URI в формате "ключ=значение".
            <br><b>Cookie</b> могут передаваться в request headers в формате "ключ: значение". 
            Это один из способов идентификации пользователя и сохранения информации о его предпочтениях.
            <br><br><b>Примечание 1.</b>
            <br>В методах GET, HEAD, OPTIONS request body не используется.

            <br><b>Примечание 2.</b>
            <br>В методе DELETE body может присутствовать, но также может и отсутствовать. Это зависит от реализации разработчика.

            <br><b>Примечание 3.</b>
            <br>В версиях HTTP 1.1 и выше заголовок Host является обязательным, и в нем указывается доменное имя. В стартовой строке указываются протокол, метод и эндпоинт. Ниже есть пример, как это выглядит.

            <br><b>Примечание 4.</b>
            В стартовой строке может содержаться как абсолютный URI, так и относительный URI (только эндпоинт). Чаще всего в стартовой строке передается относительный URI (эндпоинт).

            <br><b>Примечание 5.</b>
            Технически, query-параметры могут отправляться с любым методом HTTP. Чаще всего они отправляются с методом GET и, в основном, используются для фильтрации и сортировки данных.

            <u><h3>HTTP Response</h3></u>
            <b>Response</b> — это ответ, который мы получаем от сервера. Response состоит из следующих частей:

            <ol>
                <li>
                    <b>Стартовая строка</b>, в которой указывается:
                    <ul>
                        <li>Протокол и версия протокола</li>
                        <li>Статус-код</li>
                        <li>Пояснение к статус-коду</li>
                    </ul>
                </li>
                <li><b>Response headers</b> — заголовки со служебной, уточняющей и дополнительной информацией в формате "ключ: значение".</li>
                <li><b>Response body</b> — тело ответа.</li>
            </ol>

            <i>Опционально:</i>
            <br><b>Cookie</b> могут передаваться в response headers, в заголовке Set-cookie.
        </p>
        <img src="images/http1.jpg"></img>
        <br><br>
        <p>
            <b>Давайте подробнее рассмотрим, как из адресной строки при запросе формируется HTTP запрос:</b>
        </p>
        <img src="images/http2.jpg"></img>
        <p>
            Для пользователя удобно использовать адресную строку в браузере, чтобы обращаться к веб-ресурсам. Но на техническом уровне запрос выглядит несколько иначе. Рассмотрим, как это работает:

        <ol>
            <li> В начале запроса мы указываем протокол HTTP или HTTPS. Данная информация помещается в стартовую строку.</li>
            <li>Далее, мы указываем доменное имя www.youtube.com. Эта информация записывается в заголовок Host.</li>
            <li>Далее, следует эндпоинт с query-параметрами. Данная информация также помещается на стартовую строку</li>
            <li>Поскольку мы отправляем запрос из адресной строки браузера, метод запроса по умолчанию устанавливается как GET.</li>
        </ol>
        </p>

        <p>
            <u><h3>Cтатус-коды</h3></u>
            Статус-код приходит от сервера в ответ на запрос и представляет собой трехзначное число в диапазоне от 100 до 599. 
            Это число несет информационный характер о результате обработки запроса сервером.

            <br><br>В протоколе HTTP статус-коды подразделяются на пять категорий:
            <br>
            <br>100-199: Информационные ответы.
            <br>200-299: Успешная обработка запроса.
            <br>300-399: Перенаправление запроса.
            <br>400-499: Ошибки клиента.
            <br>500-599: Ошибки сервера.
            <br>Обобщенно, ответы со статус-кодами в диапазоне от 200 до 399 считаются успешными.

            <br><br>Хотя разработчики и определяют статус-коды для своих приложений, хорошей практикой считается следование стандартам разработки API. Например:

            <br><b>200 OK:</b> Указывает на успешную обработку запроса, когда сервер вернул ожидаемую информацию.
            <br><b>201 Created: </b>Сообщает о том, что данные, отправленные клиентом, были успешно добавлены в базу данных.
            <br>Если при регистрации пользователя сервер возвращает ответ 200 OK вместо 201 Created, это не обязательно ошибка. 
            Но, как правило, следование стандартам считается наилучшей практикой. При тестировании API тестировщикам стоит опираться на документацию и здравый смысл. 
            Если документация указывает на ожидаемый ответ 200 OK, значит, таково решение разработчика. Но в таких ситуациях стоит уточнять документацию.

            <br><br>Наиболее распространенные статус-коды, которые желательно знать:

            <br><br><b>2XX - Успешные ответы:</b>
            <br>200 ОК - Успешный запрос.
            <br>201 Создан - сервер подтвердил создание ресурса.

            <br><br><b>3XX - Ответы о перенаправлении:</b>
            <br>300 Множественный выбор - запрос клиента имеет несколько возможных ответов.
            <br>301 Перемещено навсегда - искомый ресурс был навсегда перемещен по другому URL. Пользователи и боты будут перенаправлены на этот новый URL.

            <br><br><b>4XX - Ошибки клиента:</b>
            <br>400 Плохой запрос - клиент отправил запрос с ошибочными, неполными или недопустимыми данными.
            <br>401 Неавторизован - требуется авторизация для доступа к ресурсу.
            <br>403 Запрещено - клиент не имеет прав доступа к ресурсу.
            <br>404 Не найдено - сервер доступен, но искомая страница не найдена или не существует.
            <br>405 Метод не поддерживается - метод запроса понятен, но не допустим для конкретного ресурса. При методах GET и HEAD этот код ошибки никогда не должен возвращаться.
            <br>409 Конфликт - запрос конфликтует с внутренними операциями сервера (например, такой пользователь уже существует в базе данных).

            <br><br><b>5XX - Ошибки сервера:</b>
            <br>500 Внутренняя ошибка сервера - сервер столкнулся с проблемой, которую не смог обработать.
            <br>501 Не реализовано - говорит о том, что сервер не поддерживает или не распознает сам метод запроса (например, некий гипотетический метод FOO).
            <br>502 Bad Gateway - сервер действует как прокси или шлюз и получает недействительный ответ от вышестоящего сервера.
            <br>503 Служба недоступна - сервер временно недоступен или перегружен.
            <br>504 Gateway Timeout - сервер, действуя как шлюз или прокси, не дождался ответа от вышестоящего сервера и не может завершить обработку запроса.
            <br>505 Версия HTTP не поддерживается - сервер не поддерживает версию HTTP, указанную в запросе.
            <br><br>На собеседовании могут спросить, чем 502-й статус-код отличается от 504-го? 
            В случае 502-го статус-кода при запросе к серверу наш сервер обратился к вышестоящему серверу для получения информации и 
            получил от него некорректный ответ. А в случае с 504-м наш сервер не дождался ответа от вышестоящего сервера в принципе.
        </p>

       <p>
            <u><h3>Headers</h3></u>
            Заголовки носят служебный характер. В них указывается информация для корректной работы системы.

            <br><br>Заголовки разделяются на 4 типа:

            <b>
                <br>Заголовки запросов (Request headers)
                <br>Заголовки ответов (Response headers)
                <br>Основные заголовки (General headers)
                <br>Заголовки сущности (Entity headers)
            </b>
            <br><br><b>Request headers</b> используются при отправке запроса на сервер. Служат для передачи дополнительной, уточняющей и служебной информации. 
            Некоторые заголовки, например, User-Agent, отправляются только в request headers.

            <br><br><b>Response headers</b> используются при отправке ответа от сервера к клиенту. Также служат для передачи дополнительной,
             уточняющей и служебной информации. Некоторые заголовки могут быть отправлены только в response headers. Например, Set-cookie, 
             которые сервер генерирует и отправляет клиенту для того, чтобы клиент сохранил данные куки и при последующих запросах присылал их для идентификации 
             и аналитических целей.

            <br><br>В группу <b>General headers</b> входят такие заголовки, как Date, Connection и т.п. Данная группа заголовков не описывает содержимое запроса 
            и является общей для клиента и сервера.

            <br><br>В группу <b>Entity headers</b> входят заголовки, служащие для описания содержимого запросов. 
            Entity headers отправляются вместе с request headers или response headers. Большинство entity headers начинаются с Content-. Например:

            <br>Content-Length
            <br>Content-Language
            <br>Content-Type
            <br>Content-Location
            <br>Link и т.д.

            <br><br>На практике, как правило, разделяют запросы на request headers и response headers.
            <br>Заголовки представляют из себя набор ключей и значений key: value. 
            
            <br><br>Далее разберем некоторые распространенные заголовки.

            <h3>User-Agent</h3>
            User-Agent - этот заголовок отправляет серверу информацию о том, с какого устройства или браузера осуществляется запрос.

            <br><br>Пример заголовка User-Agent:

            <br><br>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36.
            <br>Данная информация может использоваться в аналитических целях. Например, компании могут анализировать, с каких устройств, 
            браузеров или операционных систем пользователи посещают их ресурс. Также благодаря этому заголовку, когда пользователь заходит на сайт с целью скачать приложение, система определяет его устройство и предлагает соответствующую версию программы, подходящую для его операционной системы. Для пользователя это может выглядеть как магия, но на самом деле за всем этим стоит заголовок User-Agent:)

            <h3>Host</h3>
            Host - данный заголовок указывает, к какому конкретному веб-сайту на HTTP-сервере следует обратиться. 
            <br>На одном сервере может быть размещено множество различных веб-сайтов, и заголовок Host помогает серверу определить, к какому из них обращается запрос. 
            <br>В качестве значений для этого заголовка могут выступать как доменные имена, так и IP-адреса. 
            <br><br>Стоит отметить, что заголовок Host является обязательным для HTTP версии 1.1 и выше.

            <br><br>Примеры заголовка Host:

            <br><br>Host: www.youtube.com
            <br>Host: localhost:8000


            <h3>Referer и Referrer-policy</h3>
            Referer — данный заголовок используется для указания источника, откуда был отправлен текущий запрос. 
            <br>Если, например, пользователь кликнет на логотип Stepik в верхнем левом углу какой-либо страницы, переходя на главную, к запросу будет добавлен 
            заголовок вида Referer: https://stepik.com/lesson....

            <br><br>Referrer-policy — этот заголовок определяет, какой именно информацией заполнять заголовок Referer. 
            Это может быть, например, только URL или полный URI. Этот заголовок важен с точки зрения безопасности и конфиденциальности, 
            так как позволяет контролировать, какие данные и в каких обстоятельствах будут передаваться в Referer.

            <br><br>Если говорить простыми словами, Referrer-policy диктует, какие данные и в каких случаях должны передаваться в Referer.

            <br><br>Примеры заголовка Referrer-policy:

            <br><br>Referrer-Policy: no-referrer - заголовок Referer не указывается
            <br>Referrer-Policy: no-referrer-when-downgrade - заголовок Referer не указывается при переходе с HTTPS на HTTP
            <br>Referrer-Policy: origin - в  Referer указывается только URL
            <br>Referrer-Policy: origin-when-cross-origin - при переходах внутри одного ресурса по HTTPS в Referer указывается URI. В иных случаях - только URL.
            <br>Referrer-Policy: same-origin - при переходах внутри одного ресурса в Referer указывается URI. При переходах на другой ресурс Referer не передается. 
            <br>Referrer-Policy: strict-origin - при переходах с HTTPS на HTTP Referer не передается. В ином случае передается URL.
            <br>Referrer-Policy: strict-origin-when-cross-origin - при переходах внутри одного ресурса по HTTPS передается URI. При переходах по HTTPS на сторонние ресурсы - передается URL. При переходе на сторонний ресурс с HTTPS на HTTP - Referer не передается.
            <br>Referrer-Policy: unsafe-url - всегда передается URI, вне зависимости от безопасности ресурса.

            <h3>Accept</h3>
            Accept- заголовок, который позволяет клиенту указать, какие типы медиафайлов он может принять и обработать. 
            В данном заголовке могут быть указаны несколько типов, перечисленные через запятую.

            <br><br>Примеры заголовка Accept:

            <br><br>Accept: */* - клиент может принять и обработать любой формат.
            <br>Accept: text/html - клиент может принять и обработать только формат HTML
            <br>Accept: text/html, application/json - клиент может принять и обработать формат HTML и JSON

            <h3>Authorization</h3>
            Authorization- Используется для идентификации пользователя. Является уникальным для каждого пользователя, 
            выдается системой после успешной идентификации пользователя. Хранится на стороне клиента и отправляется серверу для аутентификации. 
            Бывают разные способы аутентификации.

            <br><br>Пример заголовка Authorization:

            <br>Authorization: Bearer 12iDASnf_dsASk32...

            <h3>Set-Cookie</h3>
            Set-Cookie - Сервер генерирует куки и отправляет их клиенту чтобы клиент хранил их и отправлял при последующих запросах. 
            Куки передаются в формате name=value. 

            <br>Куки - это небольшие фрагменты данных, которые хранятся как на стороне клиента, так и на стороне сервера, и служат в целях идентификации. 
            Куки передаются вместе с запросом в заголовке Cookie для поддержания доступа клиента к ресурсу. Куки могут использоваться и для других целей, 
            например, для хранения предпочтений на сайте или отслеживания клиентской сессии.

            <br><br>Пример заголовка Set-Cookie:

            <br><br>Set-Cookie: NIm=NOvTiKlzkb_PPzaFOwA40FxDY8_3qtOKZhY;
            <br>Set-Cookie: csrftoken=un151mMlOp38;

            <br><br>У заголовка Set-Cookie, существуют атрибуты служащие для управления куками. Рассмотрим распространенные атрибуты:

            <br><br>Expires=&#8249;дата и время&#8250; - устанавливает максимальную дату и время жизни куки.
            <br>Max-Age=&#8249;кол-во секунд&#8250; - устанавливает максимальное время жизни кук в секундах. Имеет приоритет перед Expires.
            <br>Domain=&#8249;доменное имя&#8250; - указывает на какой хост должны отправляться куки.
            <br>Path=&#8249;/эндпоинт&#8250; - указывает по какому эндпоинту должны отправляться куки. Если значение Path=/, значит куки отправляются по всем эндпоинтам.
            <br>Secure - означает, что куки могут отправляться только на ресурс использующий защищеный протокол HTTPS.
            <br>HttpOnly - предназначен для защиты от кражи кук вредоносным скриптом JavaScript. Блокирует доступ JavaScript к кукам. 
            <br>SameSite=Strict - куки передаются только при переходах внутри одного и того же ресурса. Например: если vk.com отправил нам куки с данным атрибутом, и мы переходим с google.com на vk.com, то при этом переходе куки не будут отправлены. Но при последующих переходах внутри vk.com куки будут прилагаться к запросам.
            <br>SameSite=Lax - куки передаются при межсайтовых переходах по прямой ссылке. Например, если переходим с google.com на vk.com, куки будут отправлены. Отличие атрибута SameSite=Lax в том, что куки отправляются только при переходе по прямой ссылке. Так, если с google.com в разделе "картинки" мы скачиваем картинку с другого сайта, куки передаваться не будут. В случае отсутствия атрибута SameSite, по умолчанию с 2019 года применяется значение SameSite=Lax.
            <br>SameSite=None; Secure - данный атрибут снимает ограничения по передаче куки. Данный атрибут может передаваться только по защищенному протоколу HTTPS и с атрибутом Secure, который мы рассматривали выше.
            <br><br>Примеры заголовка Set-Cookie с атрибутами:

            <br><br>Set-Cookie: NIm=NOvTiKlzkb_PPzaFOwA40FxDY8_3qtOKZhY; SameSite=None; Secure
            <br>Set-Cookie: csrftoken=un151mMlOp38; Max-Age=360000; SameSite=Strict; Domain=vk.com; HttpOnly
            <br><br><b>Примечание 1.</b>
            <br>Куки отправленные сервером без атрибута Expires или Max-Age - являются сессионными и существуют во время текущей сессии, пока открыт браузер.

            <br><br><b>Примечание 2.</b>
            <br>Куки в которых присутствует атрибут Expires или Max-Age - являются постоянными.

            <h3>Cookie</h3>
            <br>Cookie — данный заголовок используется клиентом для отправки серверу кук, полученных через Set-Cookie. 
            <br>Заголовок содержит в себе одну или несколько пар в формате name=value. Пары кук разделяются символом ;.

            <br><br>Пример заголовка Cookie:
            <br>Cookie: NIm=NOvTiKlzkb_PPzaFOwA40FxDY8_3qtOKZhY; csrftoken=un151mMlOp38;
            

            <h3>Content-Type</h3>
            Сontent-Type - используется для информирования о формате содержимого body, отправляемого на сервер или получаемого от сервера.

            <br><br>Примеры заголовка Content-Type:

            <br><br>Content-Type: application/json
            <br>Content-Type: application/xml
            <br>Content-Type: application/x-www-form-urlencoded
            <br>Content-Type: text/html

            <h3>Cache-Control</h3>
            Если говорить простыми словами, кэш — это буфер с быстрым доступом. Можно представить кэш как папку с копиями документов и файлов или как мини-базу данных, 
            где хранится информация, которая часто используется и редко обновляется. Преимуществом кэша является значительное увеличение производительности ресурса
            благодаря уменьшению нагрузки на сервер и быстрому доступу к запрашиваемым данным. Однако у кэша есть и недостатки: ограниченный объем памяти и 
            риск получения устаревшей информации.

            <br><br>Существует множество видов кэшей. 
            <br>Спецификация HTTP 1.1, ради безопасности и конфиденциальности, разделяет кэши на две группы: <i>общие (Shared) и необщие (Non-Shared)</i>.

            <br><br><b>Общие (или публичные) кэши</b> — это кэши, к которым есть доступ у большого количества людей. К ним относятся кэши провайдеров, 
            кэши компаний и так далее. Общий кэш выступает промежуточным звеном между клиентом и сервером, фактически являясь прокси-сервером.

            <br><br><b>Необщий (или приватный) кэш</b> — это кэш, доступ к которому имеет только один пользователь, например, кэш браузера.

            <br><br>В протоколе HTTP существует несколько заголовков, предназначенных для управления кэшированием:

            <br><br><b>Cache-Control</b> — ключевой и основной заголовок для управления кэшем. Появился в версии HTTP 1.1 и имеет приоритет перед Expires и Pragma.
            <br><b>Expires</b> — предшественник Cache-Control. Он менее гибкий и, в основном, используется для обратной совместимости со старыми браузерами.
            <br><b>Pragma</b> — устаревший заголовок, который уже редко используется в современных приложениях.

            <br><br>Заголовок Cache-Control является общим (General header). Управление кэшированием с его помощью происходит как при запросах со стороны клиента, 
            так и при ответах со стороны сервера.

            <br><br>Распространенные <b>атрибуты Cache-Control, в клиентских запросах:</b>

            <br><br>max-age=&#8249;секунды&#8250; - клиент готов принять ответ, который можно закэшировать на указанное время.
            <br>max-stale=&#8249;секунды&#8250; - клиент готов принять устаревший ответ, в котором время устаревания не превышает указанное количество секунд. Данный атрибут может быть полезен когда сервер не доступен.
            <br>min-fresh=&#8249;секунды&#8250; - клиент готов принять ответ, который будет актуальным указанное кол-во секунд.
            <br>no-cache - перед использованием закэшированных данных, кэш должен проверить актуальность на сервере.
            <br>no-store - запрет на кэширование каких-либо данных о запросе и ответе.
            <br>no-transform - запрет на преобразование(конвертацию) данных на стороне кэша.
            <br>only-if-cached - клиент готов получить любую закэшированную информацию. Данный атрибут может быть полезен, когда сервер не доступен.

            <br><br>Распространенные <b>атрибуты Cache-Control, в ответах от сервера:</b>

            <br>public - данные можно закэшировать в любом кэше (в общем кэше и кэше браузера).
            <br>private - данные можно закэшировать только в приватном кэше(в кэше браузера).
            <br>max-age=&#8249;секунды&#8250;- сервер указывает, на какое время кэшируются данные с момента создания ответа. По сути данным атрибутом, сервер обозначает срок свежести закэшированных данных. Обратите внимание, что время кэширования начинается не с момента получения, а с момента создания контента.
            <br>s-max-age - аналогичен max-age, за исключением того, что предназначен для общих кэшей. Если присутствуют одновременно оба атрибута, max-age - будет определять время свежести в кэше браузера, а s-max-age - будет определять время свежести в общем кэше.
            <br>no-cache - перед использованием закэшированных данных, кэш должен проверить актуальность на сервере.
            <br>no-store - запрет на кэширование каких-либо данных о запросе и ответе.
            <br>no-transform - запрет на преобразование(конвертацию) данных на стороне кэша.
            <br>must-revalidate - после истечения срока свежести, кэш обязан проверить актуальность данных у сервера.
            <br>proxy-revalidate - аналогичен предыдущему, за исключением того, что распространяется на общие кэши.

            <br><br>Обратите внимание на отличия no-store от no-cache. no-store - запрещает кэшировать запросы и ответы, 
            а no-cache - указывает кэшу, что перед тем, как ответить клиенту, он должен сначала обратиться к серверу и убедиться, что информация не поменялась. 

            <br><br>Так же, про отличия no-cache от must-revalidate. В случае с no-cache, кэш каждый раз обращается к серверу, 
            даже если срок свежести не истек. В случае с must-revalidate, кэш должен обратиться к серверу только после того, как истек срок свежести. 

            <h3>Connection</h3>
            Connection - служит для управления соединением между клиентом и сервером.

            <br><br>Примеры заголовка Connection:
            <br>Connection: keep-alive - соединение между клиентом и сервером не прерывается.
            <br>Connection: close - говорит о том, что сервер или клиент хотят прекратить связь.

            <h3>Accept-Language</h3>
            Accept-Language представляет информацию о языке, которому отдаёт предпочтение пользователь.
            <br>Пример заголовка Accept-Language:
            <br><br>Accept-Language: ru-RU, ru, en-US, en — система выберет язык в порядке убывания. 
            <br>Сначала система попробует отобразить информацию на русском языке. Если не удастся, предоставит информацию на английском языке. 
            <br>Если и на английском языке не удастся, в этом случае предоставит язык, установленный по умолчанию.
            <span>_________________________________________________________________________________________</span>
            <br>На самом деле, хедеров довольно много. Выше приведены некоторые из основных. Также бывают кастомные хедеры, 
            созданные разработчиками для реализации функционала системы. Как правило, они начинаются с атрибута <b>x-</b>.
            <br>Также хочу обратить внимание, что Content-Type используется не для выбора формата ответа, а лишь для информирования о том, 
            в каком формате был направлен запрос или получен ответ. Для выбора формата используется хедер Accept.
       </p>

       <p>
        <h3><u>CRUD -   методы GET, POST, PUT, PATCH, DELETE</u></h3>

<h3>Безопасные и идемпотентные методы</h3>
Идемпотентные методы - это методы, которые либо не изменяют состояние в базе данных, либо изменяют состояние только при первом запросе. В случае повторной отправки идентичного запроса, состояние в базе данных не изменяется.

Идемпотентными методами являются: GET, PUT, DELETE, HEAD и OPTIONS. POST и PATCH не входят в эту группу.

Безопасные методы - это методы, которые не изменяют состояние в базе данных (read only методы). Примечательно, что все безопасные методы также являются идемпотентными.

Безопасными методами являются: GET, HEAD и OPTIONS.

Отличие идемпотентных методов от безопасных заключается в том, что безопасные методы не меняют состояние базы данных, в то время как идемпотентные методы могут внести изменения при первом запросе, но последующие идентичные запросы уже не будут менять состояние в базе данных.

Пример №1: нарушение идемпотентности методов.

Идемпотентная реализация метода DELETE: при первом запросе на удаление http://example.com/users/5 вернулся 204 No Content, а дальнейшая повторная отправка аналогичного запроса возвращает 404 Not Found.
Некорректная реализация метода DELETE: при каждом запросе на удаление http://example.com/users, удаляется последний зарегистрированный пользователь.
Пример №2: нарушение безопасности методов.

Безопасная реализация метода GET: при отправке GET запроса http://example.com/users/5/balance возвращается баланс пользователя с id=5.
Реализация метода GET с нарушением безопасности метода: разработчики реализовали query-параметр update_balance и теперь клиент может обновлять свой баланс отправляя http://example.com/users/5/balance?update_balance=10. 

В данном примере нарушена безопасность метода GET, так как клиент меняет состояние на серверной стороне при первом запросе. При этом здесь не нарушена идемпотентность, так как повторная отправка аналогичного запроса не будет менять баланс.
Реализация метода GET с нарушением безопасности и идемпотентности: разработчики реализовали query-параметры plus  и minus. Теперь клиент может увеличить свой баланс отправляя http://example.com/users/5/balance?plus=10 и уменьшить свой баланс отправляя http://example.com/users/5/balance?minus=10.

В данном примере нарушена и безопасность, и идемпотентность метода GET, так как клиент меняет состояние на серверной стороне при каждом запросе.
Таблица безопасных и идемпотентных методов:

 	<pre>
 	        
                               GET    POST     PUT    PATCH   DELETE
            Безопасный	        +	-	-	-	-
            Идемпотентный	+	-	+	-	+
 	</pre>


<h3>Метод GET</h3>
Метод GET - используется для получения информации о ресурсе.

Каждый раз, когда мы открываем страницу https://www.google.com или любую другую страницу - мы отправляем GET запрос на сервер для получения информации с данного ресурса. Точно также, когда мы смотрим вакансии на hh и открываем страницу работодателя, например: https://hh.ru/employer/1455?hhtmFrom=vacancy_search_list&dpt=hh-1455-QA, мы запрашиваем у сайта hh.ru, по эндпоинту: /1455?hhtmFrom=vacancy_search_list&dpt=hh-1455-QA информацию об интересующем нас ресурсе. 

GET запрос может отправляться вместе с query-параметрами. Query-параметры служат для фильтрации и сортировки данных. Если в нашем запросе несколько разных query-параметров, мы разделяем их символом &.

Query-параметры представляются в формате key=value. Например: ?limit=10&offset=3. limit - это ключ, 10 - это значение. offset - ключ, 3 - значение.

Чтобы наглядно посмотреть как работают query-параметры, давайте выполним следующие шаги:

Переходим по ссылке:  https://hh.ru/employer/1455?hhtmFrom=vacancy_search_list&dpt=hh-1455-QA.
Видим, что вакансии отфильтрованы по параметру QA.
Пробуем заменить значение QA в нашем URI на значение iOS.
Смотрим на результат.
Можете попробовать понажимать на разные категории вакансий в хед-баре, например на Android или Дизайн и посмотреть, какие будут применяться значения в query-параметрах.
Также стоит запомнить, что методы GET и HEAD - являются кэшируемыми. 

<h3>Метод POST</h3>
Метод POST предназначен для создания новых ресурсов и передачи данных. Когда мы создаем пользователя, оформляем заказ или бронируем авиабилет, чаще всего используется данный метод. Отличие POST от PUT заключается в том, что POST не является идемпотентным. Другими словами, если мы трижды отправим запрос методом POST для оформления заказа, он создаст 3 заказа. В то время как метод PUT каждый раз будет заменять уже созданный заказ. Обычно именно метод POST применяется для добавления новых данных в базу данных.

Для передачи данных в методе POST используется тело запроса. Эти данные могут отправляться в различных форматах, примеры:

JSON;
XML;
text;
бинарные файлы (изображения, видео, аудиофайлы и т.д.);
Слева пример регистрации пользователя, глазами самого пользователя. Справа та же самая регистрация на том же ресурсе, с теми же данными, в формате JSON.



Резюмируя, про метод POST: 

Для создания новых ресурсов и для передачи данных - следует использовать метод POST.
В отличие от GET, метод POST использует тело (body), которое отправляется на сервер.
POST не является идемпотентным, в отличие от методов GET, PUT и DELETE.
В теле запроса можно передавать информацию в разных форматах, хотя наиболее распространенным является формат JSON.
POST может быть кэширован при определенных условиях, хотя такая практика редко используется.


<h3>Методы PUT и PATCH</h3>
Для обновления информации уже существующего объекта часто используется метод PUT. Также этой цели может служить метод PATCH, но принципы их работы различаются.

Метод PUT обновляет ресурс полностью, в то время как метод PATCH вносит частичные изменения в существующем ресурсе, затрагивая только указанные поля, переданные в теле запроса.

Метод PUT является идемпотентным. Это означает, что если мы отправим один и тот же запрос PUT десять раз, результат будет одинаковым. При первом вызове PUT внесет изменение в базу данных, а последующие вызовы будут заменять тот же объект теми же данными.

С другой стороны, метод PATCH может использоваться не только для обновления, но и для добавления данных. В случае многократного вызова одинакового запроса метод PATCH приведет к внесению соответствующего количества изменений в базу данных.

Еще одна особенность метода PUT:

Например, у нас есть объект в котором есть 5 полей:

{

    "email":"example@mail.ru",

    "first_name":"exampleName",

    "last_name":"exapmleLastName",

    "password":"s7CUgSevd5D!uu4",

    "phone":"+79991112233"

}
И мы захотим заменить наш номер телефона методом PUT следующим образом:

{

    "phone":"+71112223344"

}
В итоге мы получим удаление четырех оставшихся полей, так как PUT обновляет объект целиком. Если бы мы обновляли таким образом используя метод PATCH, то обновилось бы только поле "phone". 

Соответственно, корректная замена данных методом PUT будет выглядеть следующим образом:

{

    "email":"example@mail.ru",

    "first_name":"exampleName",

    "last_name":"exampleLastName",

    "password":"s7CUgSevd5D!uu4",

    "phone":"+71112223344"

}
Резюмируя про метод PUT и PATCH:

PUT меняет объект целиком.
PATCH вносит изменения в существующий объект, меняя только указанные в body поля.
PUT по определению идемпотентный.
PATCH может быть идемпотентным, но может и не являться таковым (пример с настройкой на добавление). Несмотря на то, что PATCH может являться идемпотентным, но не всегда является таковым - PATCH относиться к категории неидемпотентных.
PUT более распространен, чем PATCH.
При внесении изменений в одно из нескольких полей методом PUT, для корректной замены данных, следует прописывать все остальные поля с нужными значениями.
Метод PATCH, как и метод POST может быть кэширован при определенных условиях, но это редко используется. В свою очеред PUT не кэшируется.
Для большей наглядности разница между PUT и PATCH:



Примечание.

В формате JSON входные и выходные данные отличаются от приведенных в схеме выше. Эта схема предназначена для наглядности работы PUT и PATCH. Для JSON и JSON-Schema, в курсе посвящен отдельный блок.

<h3>Метод DELETE</h3>
Если нам необходимо удалить неправильно сформированный заказ в интернет-магазине, пользователя в социальной сети или фотографию в Instagram, мы используем метод DELETE. Метод DELETE может иметь тело запроса, но также может и не иметь, но как правило, тело запроса в методе DELETE не используется.

Пример DELETE запроса, на удаление пользователя с id=123:

DELETE /users/123 HTTP/1.1
Host: example.com
После успешного выполнения метода DELETE мы можем получить различные статус-коды и тела ответа от сервера:

200 OK указывает на успешное выполнение удаления, и ответ содержит тело.
202 Accepted используется, если удаление будет успешным, но еще не завершено.
204 No Content означает, что удаление было выполнено, но тело ответа отсутствует.
401 Unauthorized возникает, если попытка удаления выполняется без авторизации.
403 Forbidden указывает на отсутствие прав на выполнение данной операции.
404 Not Found возникает, если попытка удаления направлена на несуществующий или ненайденный ресурс.
Как и метод PUT, метод DELETE не поддерживает кэширование.

Про реализацию методов на проектах и про некоторые вопросы на собеседованиях.
На собеседованиях, зачастую любят задавать вопрос, на подобии следующего: "Можно ли методом GET, зарегистрировать пользователя?". Вопрос, на самом деле довольно коварен, так как выше мы выяснили, что, если мы хотим отправить запрос на регистрацию пользователя, во первых мы должны использовать метод POST, для того, чтобы сервер понял, какое действие мы от него ждем(внесения переданных данных в БД) и во вторых, всю необходимую информацию для регистрации, мы передаем в body. А в методе GET - body не используется. 

На самом деле с помощью метода GET - можно зарегистрировать пользователя. И вообще, можно все действия на ресурсе реализовать с помощью GET или любого другого метода. Все зависит от реализации разработчика. Проблема заключается в том, что, во первых это не правильно, во вторых не безопасно, в третьих, если на проекте REST архитектура - это противоречит принципам REST. Разработчик при написании серверной части и API, должен придерживаться устоявшимся правилам проектирования ресурса. Самым авторитетным источником использования протокола HTTP - является спецификация HTTP 1.1, в которой указано, как следует реализовывать методы HTTP. 

Параметры, для регистрации пользователя при помощи метода GET, передавались бы в query-параметрах, включая логины, пароли и прочую информацию. Любой, кто получил бы доступ к браузеру или трафику, легко смог бы узнать, Ваш логин и пароль из адресной строки. В случае с методом POST, мы передаем данные в body, который скрыт от глаз юзера.

Вопрос, который вы можете встретить на собеседовании: "Для чего, нам разделять request на хедеры, query-параметры, body?". 

Ответ заключается в том, что каждый из вышеперечисленных параметров, выполняет свою функцию. К примеру, если бы мы передавали query-параметры в хедерах, то во первых, юзер не смог бы видеть query-параметры и ключевое, юзер не смог бы добавить страницу с нужными параметрами в закладки или в избранное браузера.

В query-параметрах передаются открытые данные, в request headers - скрытые, например token, в request body - тело запроса.

Таким образом:

В query-параметрах передаются открытые данные в формате ключ=значение, которые чаще всего используются для сортировки и фильтрации данных.
В хедерах передается метаинформация (служебная/уточняющая/дополнительная информация), в формате ключ: значение.
В теле запроса передаются данные, имеющие отношение непосредственно к запросу (полезная нагрузка), которая чаще всего используется для внесения или обновления данных в БД.
Данные в теле запроса могут передаваться в различных форматах, например:
- JSON, XML
- HTML
- Бинарные файлы (картинки, видео, аудио и т.д.)
Вопрос: "Что произойдет, если мы попытаемся отредактировать несуществующий объект методом PUT и PATCH?"

Ответ: Метод PUT - может быть настроен так, что при обновлении несуществующего объекта будет создан новый ресурс в БД и это зависит от реализации разработчиков. Но если мы сделаем тоже самое методом PATCH, мы получим ошибку, ввиду того, что мы не можем частично изменить несуществующий объект.

Разница в создании ресурса между PUT и POST, заключается следующем:

При создании ресурса методом POST, система самостоятельно присваивает идентификатор (например id) созданному ресурсу, когда при создании ресурса методом PUT, в запросе должен быть указан создаваемый идентификатор.
Создание ресурса методом POST неидемпотентно, когда создание ресурса методом PUT является идемпотентным, т.к. при первом запросе создастся ресурс с указанным идентификатором, а дальнейшая повторная отправка запроса, не будет создавать новые ресурсы и изменять созданный ресурс.
Вопрос: "Может ли быть у метода GET request body?". Еще один вопрос с подвохом, в дополнение к первому вопросу:)

Ответ: Да, может. Только ни один браузер не может отправить request body в GET запросе. И даже если это сделать, нормально реализованный ресурс "развернет" этот запрос или просто проигнорирует request body. В спецификации HTTP - явно не указано, что нельзя отправлять в методе GET тело запроса. Но в спецификации, явно определено предназначение GET - это получение информации. А для запроса и получения информации - тело запроса не нужно. Тело запроса - используется для передачи информации, а GET - для этого не предназначен.
       </p>

    </div>

   <footer>
    &copy; 2023 Creative Java cheat sheet :: JAVA&#160;Core
   </footer>
</body>
</html>