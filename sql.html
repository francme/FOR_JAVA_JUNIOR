<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FOR JAVA JUNIOR</title>
    
    <link rel="stylesheet" href="style.css">

</head>

<body>

   <header>
        <h1>JAVA-DEV</h1>
   </header>

   <nav class="mainNav">
       <a href="#">ООП</a>
       <a href="#">SOLID</a>
       <a href="datastructures.html">Data&#160;structures</a>
       <a href="algorithms.html">Алгоритмы</a>
       <a href="home.html">JAVA&#160;Core</a>
       <a href="#">Json</a>
       <a href="#">STREAM&#160;API</a>
       <a href="#">REST&#160;API</a>
       <a href="#">JUnit</a>
       <a href="sql.html">SQL</a>
       <a href="#">HTML5</a>
       <a href="#">Jsoup</a>
       <a href="#">CSS</a>
       <a href="#">JS</a>
       <a href="#">MAVEN</a>
       <a href="#">Git</a>
       <a href="#">Spring&#160;Framework</a>
       <a href="#">Hibernate</a>
       <a href="#">Docker</a>
       <a href="#">Хэширование</a>
       <a href="#">Patterns</a>
       <a href="#">Микросервисная&#160;архитектура</a>
   </nav>

   <div class="hero">
       <h1>JAVA-DEVOLOPMENT FOR JUNIOR</h1>
       <p>Эта страница создана для помощи в подготовке Junior-разработчика.</p>
       <p>Исключительно для личного пользования.</p>
   </div>

  
<div class="content">
    <a href="https://dev.mysql.com/downloads/windows/installer/8.0.html">-mySQI.installer-</a>

    <nav>
        <ol class="secondMenu">
            <li><a href = "#bd"><span>Базы Данных</span></a></li>
            <li><a href = "#codd"><span>Двенадцать правил Кодда</span></a></li>
            <li><a href = "#norm"><span>Нормализация БД</span></a></li>
            <br>
            <li><a href = "#sql"><span>Создание БД в MySQL</span></a></li>
            <li><a href = "#types"><span>Типы данных в SQL</span></a></li>
            <li><a href = "#moper"><span>ОПЕРАТОРЫ: арифметические, сравнения, логические</span></a></li>
            <li><a href = "#constraints"><span>Ограничения</span></a></li>
            <li><a href = "#agr"><span>ВСТРОЕННЫЕ ФУНКЦИИ</span></a></li>
            <br>
            <li><a href = "#table"><span>CREATE TABLE, ALTER TABLE, TRUNCATE TABLE</span></a></li>
            <li><a href = "#select"><span>SELECT, INSERT, UPDATE, DELETE</span></a></li>
            <li><a href = "#join"><span> JOIN, GROUP BY, ORDER BY, WHERE, HAVING, OFFSET</span></a></li>
            <li><a href = "#union"><span>UNION, UNION ALL</span></a></li>
            <li><a href = "#like"><span>LIKE, REGEX, DISTINCT</span></a></li>
            <li><a href = "#limit"><span>TOP, LIMIT, ROWNUM</span></a></li>
            <li><a href = "#cycles"><span>Запросы SELECT</span></a></li>
            <li><a href = "#cycles"><span>Вложенные запросы</span></a></li>
            <li><a href = "#temp"><span>Временные таблицы</span></a></li>
            <br>
            <li><a href = "#tran"><span>ТРАНЗАКЦИИ</span></a></li>
            <li><a href = "#acid"><span>ACID (Atomicity, Consistency, Isolation, Durability)</span></a></li>
            

            <li><a href = "#view"><span>Представления, Хранимые процедуры и Триггеры</span></a></li>
            <li><a href = "#opti"><span>Оптимизация запросов</span></a></li>
        </ol>
    </nav>
    <br><br><br>
    <h2><a name="bd">&#10003; Базы Данных</a></h2>
    <p>
        <br>Базы данных используются для хранения и обработки различной информации уже не один десяток лет и будут актуальны еще длительное время.
        <br>Исследования по созданию баз данных стали возможны благодаря появлению программируемого оборудования обработки записей и
        начались в конце 50-х годов прошлого столетия. Основной идеей этих исследований была автоматизация офисной работы, связанная сохранением и
        учетом данных, которая выполнялась вручную и требовавшая больших затрат труда. Благодаря удешевлению вычислительных мощностей для решения этих 
        задач стало возможным использование компьютеров.
        <br>Лидером в сфере исследований баз данных была компания IBM, которая в 1968 году выпустила свою первую систему управления базами данных IMS (IBM 
        Information Management System), основанную на иерархической модели данных. 
        <br>Всередине 70-х годов прошлого столетия компания IBM создала первую реляционную систему управления базами данных (РСУБД) — IBM System R, 
        в которой впервые был реализован язык запросов для реляционных баз данных — <b>Structured Query Language (SQL)</b>.
        <br>В 1979 году компания Oracle выпустила первую коммерческую РСУБД Oracle v2, вслед за этим различные компании выпустили свои коммерческие продукты. 
      
        <br><br>База данных (БД) — это коллекции связанных данных, сгруппированных в единый объект. Допустим, при создании базы данных какого-то 
        учебного заведения, мы размещаем в ней необходимые наборы данных (информация о студентах, преподавателях, факультетах и т.д.), 
        и впоследствии управляем полученной БД при помощи программного обеспечения как единым целым.
        <br>Специализированное программное обеспечение, позволяющее работать с базами данных (обновлять, извлекать данные и т.д.), 
        имеет общее название <b>система управления базами данных (СУБД)</b>, например Microsoft SQL Server, Access, Oracle Database и т.д.
        <br>СУБД состоит из ряда серверных и клиентских средств, которые позволяют выполнять администрирование баз данных и различные действия, 
        связанные с манипуляцией данными. Практически любая СУБД позволяет обрабатывать запросы на извлечение и изменение данных, 
        предоставляет механизмы для резервного копирования и восстановления данных, оптимизирует производительность выполнения запросов, управляет памятью.
    </p>
    <h3>Сравнение существующих моделей баз данных</h3>
    <p>
        <br>Модели баз данных различаются правилами взаимосвязи основных типов структур данных и операциями над ними. 
        Каждая СУБД использует логическую структуру хранения данных, которая зависит от конкретной модели хранения данных, 
        рассмотрим далее наиболее часто используемые модели баз данных.
        <h4>Файловая модель</h4>
        Файловая модель данных характеризуется определенным набором файлов, не связанных между собой, 
        основными типами структур данных которой являются поле, запись, файл. 
        <br>Поле — это элементарная, неделимая единица данных. 
        <br>Запись — это совокупность логически связанных полей. 
        <br>Файл — это множество записей, одинаковых по структуре.
        <br>Файловая модель была первой моделью хранения данных, ее можно считать моделью без СУБД, 
        ведь внутренняя структура файлов была известна только разработчику данного программного обеспечения, то есть была уникальна.
        <br><br>Файловая модель обладает рядом недостатков, перечислим основные из них:
        <br>&#8728; алгоритм управления базой данных полностью заложен в программном обеспечении, 
        при изменении структуры данных необходимо вносить правки в программное обеспечение;
        <br>&#8728; сложности совместимости форматов файлов, созданных при помощи различных языков программирования, 
        из-за отличающихся друг от друга структур;
        <br>&#8728; трудности при переносе данных из одной БД в другую, по причине несовпадения структур данных;
        <br>&#8728; отсутствие централизованного хранения приводит к необходимости дублирования одних и тех же данных.
        <h4>Иерархическая модель</h4>
        Иерархическая модель представляет собой простую структуру, в которой отдельные записи организуются в отношения типа «родитель-потомок» 
        и образовывают обращенное дерево. Данные в этой иерархической структуре делятся на логические категории и подкатегории, 
        использующие записи для представления логических единиц данных.
        <br>Иерархическая модель довольно удобна для представления отношений между сущностями реального мира, 
        однако совершенно не подходит для многих современных приложений. 
        <br>Иерархическая структура не поддерживает сложные отношения между записями типа «многие ко многим», 
        потому что дочерняя запись может ассоциироваться только с одной родительской записью.
        <br>Еще одним недостатком является довольно громоздкий процесс навигации, ведь для того чтобы получить доступ 
        к записям необходимо перемещаться вверх и вниз по уровням иерархии.
        <br>Наиболее известная СУБД, созданная на основе этой модели — это IMS от компании IBM. 
        <br>Иерархическая модель нашла свое применение не только в СУБД, такая модель применяется для систем управления файлами 
        в операционных системах.
        <h4>Сетевая модель</h4>
        Сетевая модель появилась как результат усовершенствования иерархической модели, и в отличие от последней позволяет 
        записям принимать участие во множестве отношений типа «родитель-потомок». 
        <br>Хотя сетевая модель является более гибкой по сравнению с иерархической, программирование навигации 
        по записям должны осуществлять разработчики. Реализация этой модели подразумевает использование значительных ресурсов памяти, 
        потому что каждый элемент должен хранить ссылки на другие элементы. Кроме того, внесение любых изменений может привести к сложным 
        операциям обновления базы данных.
        <h4>Реляционная модель</h4>
        Выдающийся ученый Эдгар Кодд (Edgar Codd), будучи сотрудником кампании IBM, разработал реляционную модель данных, 
        которую в 1970 году описал в статье «A Relational Model of Data for Large Shared Data Banks». В 1981 году за свои исследования в области 
        баз данных он был награжден премией Тьюринга.
        <br><br><b>Реляционная модели данных не использует связь между родительскими и дочерними записями, а основана на взаимодействии 
            строк иьстолбцов, которые образуют таблицы с данными, связанными между собой.</b> 
        <br><br>Внутри базы данных, таблицы имеют уникальные названия и связываются между собой отношениями, 
        которые позволяют осуществлять навигацию по записям. Такая структура данных является очень гибкой и удобной при извлечении и изменении информации.
        В качестве примера РСУБД можно назвать: Microsoft SQL Server, Access, MySQL.
        <h4>Объектно-ориентированная модель</h4>
        Объектно-ориентированная модель данных имеет древовидную структуру, узлами которой являются объекты. 
        <br>В этой модели технология объектно-ориентированного программирования (ООП) применяется к технологии баз данных. 
        Каждая запись в базе данных является объектом, связи между записями осуществляются с помощью механизмов, которые используются в ООП. 
        Поиск необходимой записи заключается в сравнении пользовательского объекта с объектами, которые хранятся в БД.
        <br>Базовые понятия объектно-ориентированной модели полностью повторяют основные понятия ООП: класс, объект, метод, инкапсуляция, 
        наследование, полиморфизм, агрегация.
        <br>Основные недостатки модели объектно-ориентированной модели: сложность понимания ее структуры иотносительно низкая скорость выполнения запросов. 
        <br>К достоинствам этой модели можно отнести возможность хранения и отображения информации о сложных объектах, 
        с возможностью определения методов для работы с ними. Благодаря этим достоинствам некоторые РСУБД дополняются элементами 
        объектно-ориентированного проектирования, например Oracle Database, которая является объектно-реляционной СУБД.
    </p>
    <p><h3><u>Понятие реляционной модели баз данных</u></h3>
        Начиная с конца 70-х годов прошлого столетия наиболее популярной моделью баз данных, является реляционная модель, 
        в основе которой лежат математические принципы обработки данных. В реляционной модели данные представлены в виде таблиц, которые состоят из полей.
        Каждое поле предназначено для хранения определенной информации, которая характеризует конкретную сущность. 
        <br><br>В литературе, описывающей реляционную модель данных, вы можете встретить несколько другие определения: 
        так таблицы называются отношениями (англ. relation), в общем, отсюда и пошло название самой модели — реляционная, 
        запись в таблице называются кортежами, а поля — атрибутами. Однако какие бы вы названия не использовали, суть реляционной модели останется 
        прежней.
        <br>Связь между таблицами обеспечивается благодаря наличию в одной таблице уникального идентификатора из другой таблицы.
    </p>

    <h2><a name="codd">&#10003; Двенадцать правил Кодда</a></h2>
    <p>В процессе разработки реляционной модели баз данных, Эдгар Кодд сформулировал требования, которым 
        должна соответствовать любая реляционная СУБД, он опубликовал их в 1985 году. 
        <br>На самом деле основное правило имеет номер 0, поэтому всего насчитывается <b>13 правил</b>. Перечислим эти правила:
        <ol  start="0">
            <li>Основное правило: СУБД должна управлять базами данных, используя исключительно свои реляционные возможности;</li>
            <li>Правило информации: вся информация в любой базе данных должна быть представлена исключительно значениями в таблицах;</li>
            <li>Правило гарантированного доступа: каждое значение в любой таблице можно получить с помощью комбинации имени таблицы, 
                значения первичного ключа и имени столбца (имя таблицы позволяет найти требуемую таблицу, 
                имя столбца позволяет найти требуемый столбец, а первичный ключ позволяет найти строку, содержащую искомый элемент данных);</li>
            <li>Правило поддержки недействительных значений: в СУБД должна быть реализована возможность поддержки неизвестных или отсутствующих значений 
                (отсутствующие данные должны быть представлены с помощью недействительных значений (NULL));</li>
            <li>Правило динамического каталога: информация о базах данных должна храниться в виде таблиц, и СУБД должна обеспечивать стандартный доступ 
                к ней и пользовательским данным при помощи одних и тех же средств (СУБД должна содержать набор системных таблиц, 
                описывающих структуру баз данных);</li>
            <li>Правило исчерпывающего подъязыка данных: СУБД должна поддерживать хотя бы один язык, операторы которого обеспечивают все ее основные функции 
                (создание базы данных, манипулирование данными, управление доступом и т.д.);</li>
            <li>Правило обновления представлений: каждое представление должно поддерживать те же операции с данными, 
                что и таблицы (чтение, вставка, изменение и удаление данных);</li>
            <li>Правило добавления, обновления и удаления: операции связанные с изменением и удалением данных должны одинаково работать как с одной записью 
                в таблице, так и с множеством записей;</li>
            <li>Правило независимости физических данных: приложения, использующие любую базу данных, не должны зависеть от способа хранения информации
                 и аппаратного обеспечения компьютеров;</li>
            <li>Правило независимости логических данных: приложения не должны зависеть от структуры базы данных, 
                любые изменения в структуре БД не должны влиять на работу приложения;</li>
            <li>Правило независимости условий целостности: язык СУБД должен поддерживать проверку входных данных и обеспечивать их целостность;</li>
            <li>Правило независимости распространения: база данных может находиться на разных компьютерах и язык СУБД должен поддерживать 
                возможность работы с распределенными данными;</li>
            <li>Правило единственности: не должно быть возможности нарушить безопасность и целостность данных в обход языка СУБД, 
                то есть при работе с данными должен использоваться только язык СУБД.</li>
        </ol>
    </p>

    <h2><a name="norm">НОРМАЛИЗАЦИЯ БД</a></h2>
    <p>Нормализация — это процесс эффективной организации данных в БД. 
    <br>Причины, обуславливающих необходимость нормализации:
    <ul>
        <li>предотвращение записи в БД лишних данных, например, хранения одинаковых данных в разных таблицах</li>
        <li>обеспечение "оправданной" связи между данными</li>
        <li>обеспечение целостности данных и предотвращение аномалий при обновлении, вставке и удалении данных.</li>
        <li>упрощение модификации структуры базы данных и добавления новой функциональности</li>
    </ul>    
    Нормализация предполагает соблюдение нескольких форм. 
    <br>Форма — это формат структурирования БД. Нормальная форма определяет правила, которым должны соответствовать таблицы в базе 
    данных. Каждая следующая нормальная форма предполагает более строгие условия для 
    организации данных.
    <br><b>Существует три главных формы: первая, вторая и, соответственно, третья.</b> 
    </p>
    <h4>Первая нормальная форма (1NF): </h4>
    <ul>
        <li>- Устранение повторяющихся групп полей в записях и превращение их в отдельные таблицы.</li> 
        <li>- Каждая ячейка должна содержать только одно значение.</li> 
        <li>- Введение первичного ключа для уникальной идентификации каждой записи.</li>
    </ul> 
        <h4>Вторая нормальная форма (2NF):</h4> 
    <ul>
        <li>- Устранение частичной зависимости полей от составного первичного ключа.</li> 
        <li>
            - Разделение таблицы на две, чтобы каждая из них содержала только полностью зависимые 
            данные.
        </li> 
    </ul>
        <h4>Третья нормальная форма (3NF):</h4> 
    <ul>
    <li> - Устранение транзитивной зависимости полей от составного первичного ключа.</li> 
        <li>
            - Разделение таблицы на несколько, чтобы каждая содержала только непосредственно зависимые 
            данные.
        </li>
    </ul> 
        <h4>Нормальная форма Бойса-Кодда (BCNF): </h4>
    <ul>
        <li>
            - Дополнительное требование к 3NF, в котором отношение не должно иметь неключевых 
            атрибутов, зависящих от других неключевых атрибутов.
        </li> 
    </ul>

    <p>
        <i>
            Всякий раз, когда таблицы в базе данных соответствуют требованиям соответствующей 
            нормальной формы, говорят, что база данных нормализована.
        </i> 
    </p>

    <h2><a name="sql">&#10003; Создание БД в MySQL</a></h2>
    <p>Если рассматривать Oracle и MS SQL Server, то по производственным характеристикам они приблизительно одинаковы, 
        может быть по ряду показателей Oracle лучше. Главное же отличие Oracle от MS SQL Server — это 
        поддержка большого количества программно-аппаратных платформ (Linux, Windows, Mac OS и т.д.). В качестве 
        отрицательных сторон Oracle можно назвать: высокую стоимость, высокие требования к аппаратному обеспечению 
        и сложность администрирования. К тому же Oracle в основном предназначен для использования в больших 
        промышленных проектах, и в относительно простых приложениях его использование будет не рационально.
        <br><br>MySQL — это РСУБД, предназначенная для использования в простых исредних приложениях и основное ее 
        преимущество в том, что она бесплатная. К недостаткам можно отнести: ограниченную функциональность и некоторые проблемы с надежностью.
        <br><br>PostgreSQL — это свободно распространяемая объектно-реляционная СУБД, максимально соответствующая стандартам SQL, 
        поддерживаемая ОС Windows и множеством UNIX-подобных платформ. И, хотя PostgreSQL является довольно качественным программным продуктом, 
        у нее тоже есть недостатки: производительность, сложность настройки и небольшая популярность (малое количество хостингов с поддержкой этой СУБД).
        <br><br>Из всего вышеперечисленного можно сделать вывод, 
        что MS SQL Server является некой золотой серединой среди СУБД, хотя, конечно же, у нее есть и свои недостатки.
    </p>
    <p>SQL — это язык структурированных запросов (<b>Structured Query Language</b>), позволяющий хранить, манипулировать и извлекать данные из реляционных баз данных</p>
    <p>Итак, перед началом работы у вас должен быть установлен и настроен MySQL-сервер.</p>
    <pre><br>
                CREATE DATABASE my_db;
                    или
                CREATE DATABASE IF NOT EXISTS my_db;

                SHOW databases;
                
                CREATE USER 'user_db'@'%' IDENTIFIED BY 'password';
                GRANT ALL PRIVILEGES ON my_db.* TO 'user_db'@'%' WITH GRANT OPTION;
        <br>
                USE my_db;
                CREATE TABLE tableName(id INT PRIMARY KEY, column1 INT NOT NULL, column2 VARCHAR(20));
        
                DROP TABLE tableName;
                DROP database my_db;
    </pre><br><br>
    <p>Любая база данных в Microsoft SQL Server состоит из двух физических файлов. Файл с расширением .mdf — это
        основной файл данных, в нем содержится информация обо всех объектах БД. Файл с расширением .ldf — это
        файл журнала транзакций, он играет роль некоего предварительного хранилища данных. Параметры этих файлов находятся в таблице Database files.</p>

    <h2><a name="types">Типы данных в SQL</a></h2>
    <p>Каждая колонка, переменная и выражение в SQL имеют определенный тип данных (data type). 
        <br>Основные категории типов данных:
    </p>
    <img src="images\sql.png" style="width: 1024px;"></img>

    <h2><a name="moper">&#10003; ОПЕРАТОРЫ: арифметические, сравнения, логические</a></h2>
    <p>Оператор (operators) — это ключевое слово или символ, которые, в основном, используются в инструкциях WHERE 
        для выполнения каких-либо операций. 
        Они используются как для определения условий, так и для объединения нескольких условий в инструкции.
        <h4>Арифметические</h4>
        <pre>

            + (сложение)	 Сложение значений	
            — (вычитание)	 Вычитание правого операнда из левого	
            * (умножение)	 Умножение значений	
            / (деление)	         Деление левого операнда на правый	
            % (деление с остатком/по модулю) Деление левого операнда на правый с остатком (возвращается остаток)	
        </pre>
        <h4>Операторы сравнения</h4>
        <pre>
            
            =	Определяет равенство значений	
            !=	Определяет НЕравенство значений	
            <>	Определяет НЕравенство значений	
            >	Значение левого операнда больше значения правого операнда?	
            <	Значение левого операнда меньше значения правого операнда?	
            >=	Значение левого операнда больше или равно значению правого операнда?	
            <=	Значение левого операнда меньше или равно значению правого операнда?	
            !<	Значение левого операнда НЕ меньше значения правого операнда?	
            !>	Значение левого операнда НЕ больше значения правого операнда?
        </pre>
        <h4>Логические операторы</h4>
        <pre>
            
            ALL	Сравнивает все значения
            AND	Объединяет условия (все условия должны совпадать)
            ANY	Сравнивает одно значение с другим, если последнее совпадает с условием
            BETWEEN	Проверяет вхождение значения в диапазон от минимального до максимального
            EXISTS	Определяет наличие строки, соответствующей определенному критерию
            IN	Выполняет поиск значения в списке значений
            LIKE	Сравнивает значение с похожими с помощью операторов подстановки
            NOT	Инвертирует (меняет на противоположное) смысл других логических операторов, например, NOT EXISTS, NOT IN и т.д.
            OR	Комбинирует условия (одно из условий должно совпадать)
            IS NULL	Определяет, является ли значение нулевым
            UNIQUE	Определяет уникальность строки
        </pre>
    </p>

    <h2><a name="constraints">&#10003; ОГРАНИЧЕНИЯ</a></h2>
    <p>Ограничения (constraints) — это правила, применяемые к данным. 
        Они используются для ограничения данных, которые могут быть записаны в таблицу. 
        Это обеспечивает точность и достоверность данных в БД.
        <br>Ограничения могут устанавливаться как на уровне колонки, так и на уровне таблицы.
        <br><br>Среди наиболее распространенных ограничений можно назвать следующие:
    <ul>
        <li>NOT NULL — колонка не может иметь нулевое значение</li>
        <li>DEFAULT — значение колонки по умолчанию</li>
        <li>UNIQUE — все значения колонки должны быть уникальными</li>
        <li>PRIMARY KEY — первичный или основной ключ, уникальный идентификатор записи в текущей таблице</li>
        <li>FOREIGN KEY — внешний ключ, уникальный идентификатор записи в другой таблице (таблице, связанной с текущей)</li>
        <li>CHECK — все значения в колонке должны удовлетворять определенному условию</li>
        <li>INDEX — быстрая запись и извлечение данных</li>
    </ul>
    <b>Любое ограничение может быть удалено с помощью команды ALTER TABLE и DROP CONSTRAINT + название ограничения.</b> 
    <br>Некоторые реализации предоставляют сокращения для удаления ограничений и возможность отключать ограничения вместо их удаления.
    </p>

    <h2><a href="agr">&#10003; ВСТРОЕННЫЕ ФУНКЦИИ</a></h2>
    <p>
        Существует несколько встроенных функций, таких как count(), sum(), avg(), min(), max() и др. 
        для выполнения так называемых агрегирующих вычислений данных таблицы или колонки.
        AVG — вычисляет среднее значение
    <ul>
        <li>SUM — вычисляет сумму значений</li>
        <li>MIN — вычисляет наименьшее значение</li>
        <li>MAX — вычисляет наибольшее значение</li>
        <li>COUNT — вычисляет количество записей в таблице</li>
    </ul>

    Также существует несколько встроенных функций для работы со строками:
    <ul>
        <li>CONCAT — объединение строк</li>
        <li>LENGTH — возвращает количество символов в строке</li>
        <li>TRIM — удаляет пробелы в начале и конце строки</li>
        <li>SUBSTRING — извлекает подстроку из строки</li>
        <li>REPLACE — заменяет подстроку в строке</li>
        <li>LOWER — переводит символы строки в нижний регистр</li>
        <li>UPPER — переводит символы строки в верхний регистр и т.д.</li>
    </ul>

    И для работы с числами:
    <ul>
        <li>ROUND — округляет число</li>
        <li>TRUNCATE — обрезает дробное число до указанного количества знаков после запятой</li>
        <li>CEILING — возвращает наименьшее целое число, которое больше или равно текущему значению</li>
        <li>FLOOR — возвращает наибольшее целое число, которое меньше или равно текущему значению</li>
        <li>POWER — возводит число в указанную степень</li>
        <li>SQRT — возвращает квадратный корень числа</li>
        <li>RAND — генерирует случайное число с плавающей точкой в диапазоне от 0 до 1</li>
    </ul>

    Выражения для работы с датами:
    <ul>
        <li>
            CURRENT_TIMESTAMP — это и выражение, и функция (CURRENT_TIMESTAMP()) - возвращают текущую дату и время. 
            <br>SELECT CURRENT_TIMESTAMP;
            <br>Другая функция для получения текущей даты и времени — NOW().
        </li>
    
        <br>Другие функции для получения текущей даты и времени:
    
        <li>CURDATE/CURRENT_DATE — возвращает текущую дату</li>
        <li>CURTIME/CURRENT_TIME — возвращает текущее время и т.д.</li>
    
        <br>Функции для разбора даты и времени:
    
        <li>DAYOFMONTH(date) — возвращает день месяца в виде числа</li>
        <li>DAYOFWEEK(date) — возвращает день недели в виде числа</li>
        <li>DAYOFYEAR(date) — возвращает номер дня в году</li>
        <li>MONTH(date) — возвращает месяц</li>
        <li>YEAR(date) — возвращает год</li>
        <li>LAST_DAY(date) — возвращает последний день месяца в виде даты</li>
        <li>HOUR(time) — возвращает час</li>
        <li>MINUTE(time) — возвращает минуты</li>
        <li>SECOND(time) — возвращает секунды и др.</li>
    
        <br>Функции для манипулирования датами:
    
        <li>DATE_ADD(date, interval) — выполняет сложение даты и определенного временного интервала</li>
        <li>DATE_SUB(date, interval) — выполняет вычитание из даты определенного временного интервала</li>
        <li>DATEDIFF(date1, date2) — возвращает разницу в днях между двумя датами</li>
        <li>TO_DAYS(date) — возвращает количество дней с 0-го дня года</li>
        <li>TIME_TO_SEC(time) — возвращает количество секунд с полуночи и др.</li>
        <br>
        <li>Для форматирования даты и времени используются функции DATE_FORMAT(date, format) и TIME_FORMAT(date, format), соответственно.</li>
    </ul>
    </p>

    <h2><a name="table">CREATE TABLE, ALTER TABLE, TRUNCATE TABLE</a></h2>
    <h2><a name="select">SELECT, INSERT, UPDATE, DELETE</a></h2>
    <h2><a name="join">JOIN, GROUP BY, ORDER BY, WHERE, HAVING, OFFSET</a></h2>
    <h2><a name="union">UNION, UNION ALL</a></h2>
    <h2><a name="like">LIKE, REGEX, DISTINCT</a></h2>
    <h2><a name="limit">TOP, LIMIT, ROWNUM</a></h2>

    <h2><a name="cycles">ЗАПРОСЫ SELECT</a></h2>
    <h2><a name="methods">ВЛОЖЕННЫЕ ЗАПРОСЫ</a></h2>

    <h2><a name="temp">&#10003; ВРЕМЕННЫЕ ТАБЛИЦЫ</a></h2>
    <p>
        Некоторые СУБД поддерживают так называемые временные таблицы (temporary tables). 
        Такие таблицы позволяют хранить и обрабатывать промежуточные результаты с помощью таких же запросов, как и при работе с обычными таблицами.
        <br>Временные таблицы могут быть очень полезными при необходимости хранения временных данных. 
        Одной из главных особенностей таких таблиц является то, что они удаляются по завершении текущей сессии. 
        При запуске скрипта временная таблица удаляется после завершения выполнения этого скрипта. 
        При доступе к БД с помощью клиентской программы, такая таблица будет удалена после закрытия этой программы.
        <br><br>Временная таблица создается с помощью инструкции <b>CREATE TEMPORARY TABLE</b>, 
        в остальном синтаксис создания таких таблиц идентичен синтаксису создания обычных таблиц.
        <br>Временная таблица удаляется точно также, как и обычная таблица, с помощью инструкции DROP TABLE.
    </p>
    

    <h2><a name="tran">&#10003; ТРАНЗАКЦИИ</a></h2>
    <p>
        Транзакция — это набор операций по работе с базой данных (БД), объединенных в одну атомарную пачку.
        Транзакционные базы данных (базы, работающие через транзакции) выполняют требования ACID, которые обеспечивают безопасность данных. 
        <br>Транзакция — это архив для запросов к базе. Он защищает ваши данные благодаря принципу «всё, или ничего».

        <pre>

            Представьте, что вы решили послать другу 10 файликов в мессенджере. Какие есть варианты:
            
            Кинуть каждый файлик отдельно.
            Сложить их в архив и отправить архив.
            
            Вроде бы разницы особой нет. Но что, если что-то пойдет не так? 
            Соединение оборвется на середине, сервер уйдет в ребут или просто выдаст ошибку...
            
            В первом случае ваш друг получит 9 файлов, но не получит один.
            Во втором не получит ничего. 
            Нет промежуточных состояний. Или получил всё, или не получил ничего. 
            Но зато если произошла ошибка, вы снова перешлете сообщение. 
            И друг получит все файлики разом, не придется проверять «не потерялся ли кто».
        </pre>
        Транзакция — это тот же архив для запросов. Принцип «всё, или ничего».
        Или выполнены все запросы, которые разработчик упаковал в одну транзакцию, или ни один.
        <br>Транзакция — упорядоченное множество операций, переводящих базу данных из одного согласованного состояния в другое. 
        Согласованное состояние — это состояние, которое подходит под бизнес-логику системы. 

        <br><br>Чтобы сгруппировать запросы в одну атомарную пачку, используем транзакцию. Транзакцию надо:
        <br>- Открыть:  В Oracle транзакция открывается сама, по факту первой изменяющей операции. А в MySql надо явно писать «start/begin transaction».
        <br>- Выполнить все операции внутри.
        <br>- Закрыть: Тут есть 2 варианта: COMMIT — подтверждаем все внесенные изменения; ROLLBACK — откатываем их;
        
        <br>И вся фишка транзакционной базы в том, что база сначала применяет запрос «виртуально», реально ничего в базе не изменив. 
        Ты можешь посмотреть, как запрос изменит базу, ничего при этом не сохраняя(select из изменяемой таблицы, прям тут же, под своим запросом.
        Если же открыть графический интерфейс программы, то никаких изменений мы там не найдем, так как еще не был сделан COMMIT. На самом деле это удобно. 
        Ведь если мы выполняем сложную операцию, можно посмотреть на результат. И если что-то не так, то вместо коммита делаем rollback).

        <h3>Управление транзакцией</h3>
        Для управления транзакцией используются следующие команды:
        <br>
        <br>BEGIN|START TRANSACTION — запуск транзакции
        <br>COMMIT — сохранение изменений
        <br>ROLLBACK — отмена изменений
        <br>SAVEPOINT — контрольная точка для отмены изменений
        <br>RELEASE SAVEPOINT —  удаление контрольной точки
        <br>SET TRANSACTION — установка характеристик текущей транзакции, 
        используется для инициализации транзакции, т.е. начала ее выполнения. При этом, можно определять некоторые характеристики транзакции.
        
        <br><br>Команды для управления транзакцией могут использоваться <b>только совместно с такими запросами как INSERT, UPDATE и DELETE</b>. 
        Они не могут использоваться во время создания и удаления таблиц, поскольку эти операции автоматически отправляются в БД.

        <br><br>Итого:
        Транзакции могут мыслиться как обертка вокруг множества операторов SQL, которая гарантирует, 
        что либо все операторы в транзакции выполнятся успешно, либо вообще ни один из них не будет выполнен.
        Целью транзакции является обеспечение выполнения транзакции как единой атомарной операции. Это означает, 
        что либо все операции в рамках транзакции выполняются успешно, либо ни одна из них. 
        Если во время выполнения транзакции возникает ошибка, все изменения, сделанные вплоть до этого момента, будут откатываться, 
        т.е. база данных будет восстановлена в состояние, предшествующее началу транзакции.

        Одной операции всегда соответствует одна транзакция, но в рамках одной транзакции можно совершить несколько операций 
        (например, несколько разных insert можно сделать, или изменить и удалить данные...).
    </p>

    <h2><a name="acid">&#10003; ACID (Atomicity, Consistency, Isolation, Durability)</a></h2>
    <p>
        <img src="images\sqiACID.png"></img>
        <br><br>Требования ACID — набор требований, которые обеспечивают сохранность ваших данных. 
        Что особенно важно для финансовых операций. Мы же не хотим остаться без денег из-за разрыва соединения или ошибки в ПО, не так ли?
        <h3>Atomicity — Атомарность</h3>
        Атомарность гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. 
        Не допускаются промежуточные состояния.

        <br><br>Друг познается в беде, а база данных — в работе с ошибками. 
        О, если бы всё всегда было хорошо и без ошибок! 
        Тогда бы никакие ACID были бы не нужны. 
        Но как только возникает ошибка, атомарность становится очень важна.
        <pre>

            Допустим, вы решили отправить маме деньги. Когда вы делаете перевод внутри банка, что происходит:
    
            1. У вас деньги списались
            2. Маме поступили
    
            И допустим, что у нас 2 отдельных запроса. А теперь посмотрим, что будет при возникновении ошибок:
    
            1. У вас на балансе нет нужной суммы — система вывела сообщение об ошибке, но катастрофы не произошло, атомарность тут не нужна.
            2. У мамы заблокирована карточка, истек срок годности — деньги ей не поступили. Запрос отменен. 
            Но минуточку... У вас то они уже списались!
    
            Ошибка на первом этапе никаких проблем в себе не таит. 
            А вот ошибка на втором... Приводит к потере денег, что явно недопустимо.
        </pre>

        Если мы отправляем отдельные запросы, система не может связать их между собой. Запрос упал с ошибкой? Система его отменяет. 
        Но только его, ведь она не знает о том, что запрос «у меня деньги спиши» связан с упавшим «сюда положи»!
        <br><br>Транзакция же позволяет сгруппировать запросы, то есть фактически показывает базе на взаимосвязи между ними. 
        База сама о связях ничего не знает! Это знаете только вы =)
        <br>И если падает запрос внутри транзакции, база <b>откатывает всю транзакцию</b>. И приходит в состояние «как было до начала транзакции». 
        Даже если там внутри было 10 запросов, вы можете спать спокойно — сломался один, откатятся все.

        <h3>Consistency — Согласованность</h3>
        Транзакция, достигающая своего нормального завершения (EOT — end of transaction, завершение транзакции) и, 
        тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. 
        Другими словами, <b>каждая успешная транзакция по определению фиксирует только допустимые результаты</b>.
        <br><br>Это свойство вытекает из предыдущего. Благодаря тому, что транзакция не допускает промежуточных результатов, 
        база остается консистентной. 
        <br>Есть такое определение транзакции: «Упорядоченное множество операций, переводящих базу данных из одного согласованного состояния в другое». 
        То есть до выполнения операции и после база остается консистентной (в переводе на русский — согласованной).

        <pre>

            Например, пользователь в системе заполняет карточку:
    
            ФИО
            Дата рождения
            ИНН
            Телефон — отдельно код страны, города и номер
            Адрес — тоже разбит на несколько полей
    
            В базе данных у нас есть несколько таблиц:
    
            client
            phone
            address
    
            Так что когда пользователь заполнил форму и нажал «сохранить», система отправляет в базу данных 3 запроса:
    
            insert into client… -- вставить в таблицу клиентов такие-то данные
            insert into phone…
            insert into address…
    
            Можно отправить 3 разных запроса, но лучше сделать одну транзакцию, внутри которой будут эти 3 запроса.
            Атомарность гарантирует, что не получится такого, что адрес с телефоном сохранились, а сам клиент — нет. 
            Это сделало бы базу неконсистентной, ведь у нас бы появились атрибуты, «висящие в воздухе», никому не принадлежащие. 
            Что, в свою очередь, приведет к ошибкам в системе.
    
            За консистентностью должен следить разработчик. 
            Ведь это вопрос скорее бизнес-логики, чем технологий. 
            Те же атрибуты, «висящие в воздухе» — это разработчик знает, что:
    
            если есть телефон в таблице phone
            он должен ссылаться на таблицу client
    
            База об этом не знает ничего, если ей не рассказать. И она легко пропустит запрос «добавь в базу телефон без ссылки на клиента», 
            если сам по себе запрос корректный, а разработчик не повесил на таблицу foreign key.
    
            Можно повесить на таблицу constraint. Например, «баланс строго положительный». 
            Тогда сценарий с ошибкой будет выглядеть так:
    
            1.  Пользователь пытается перевести другу 100р, хотя у него самого 10
            2.  Система отправляет в базу запрос — «обнови баланс карты, теперь там X – 100».
            3.  База пытается выполнить запрос, но ой! Нарушен constraint, в итоге операции баланс стал отрицательным, 
            эту ошибку она и возвращает.
            4.  Система обрабатывает ошибку и выводит ее пользователю в читаемом виде.
    
            К сожалению, нет единого механизма рассказать базе о том, какое состояние считается согласованным. 
            Разработчик может использовать foreign ключи, какие-то констрейнты — это БД проверит. 
            Но что с одного счета списалось, а на другой пришло — это БД уже не проверит. Это бизнес-логика.
        </pre>
        Разработчик пишет код, пошагово переводящий БД в нужное согласованное состояние и, 
        если где-то посередине возникает ошибка, откатывает всю транзакцию. 
        То есть можно после каждого шага делать запрос, проверяя какое-то поле.
        Если вдруг проверка не прошла, то кидаем ошибку и делаем откат.

        <h3>Isolation — Изолированность</h3>
        Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат.
        Если у нас система строго для одного человека, проблем не будет. А если пользователей несколько? 
        Тогда транзакции запускают в параллель — для ускорения работы системы. А иначе представьте себе, 
        что вы делаете заказ в интернет-магазине и система вам говорит: «Вы в очереди, перед вами еще 100 человек хотят заказ оформить, подождите».
        Бред же? Бред!

        <br><br>Вот и приходится распараллеливать запросы. Но к каким эффектам может привести параллельная работа двух транзакций?

        <br><br><u>1 эффект: "Потерянная запись"</u>
        <br>Есть некий счет А, на котором лежит 500 у.е.
        <br>Кассир 1 списал с него 300 у.е. Списал 300, на выходе получает 200 = 500 - 300.
        <br>Кассир 2 тоже решил обратиться к этому же счету, и записал туда 300 у.е., пока К1 еще не успел закрыть свою транзакцию. 
        Так как первая транзакция не закрыта, сумма на счете до сих пор 500, получаем 500 + 300 = 800.
        <br>Итог — мы "потеряли запись" первого кассира, ведь на выходе у нас А = 800, хотя должно быть 500. 
        "Кто последний вписал результат - того и тапки". Получается так.

        <br><br><u>2 эффект: "Грязное чтение"</u>
        <br>Есть некий счет А, на котором лежит 500 у.е.
        <br>Кассир 1 списал с него 300 у.е.Списал 300. Потом передумал и сделал откат - на выходе остались те же 500 у.е.
        <br>Кассиру 2 понадобилась информация по этому счету и он ее считал до того, как К1 закрыл свою транзакцию.
        <br>Итог — второй кассир считал неверную сумму, построил неверный отчет/отказал в визе платежеспособному гражданину и т.д.

        <br><br><u>3 эффект: "Повторимое чтение"</u>
        <br>Есть некие данные.
        <br>Кассир 1 строит отчет. Операции идут последовательно для каждой колонки. 
        <br>Система считала данные, записала в первую колонку (например, взяв минимум от них).
        <br>Кассир 2 влез в эту таблицу данных и изменил некоторые счета в ней.
        <br>У кассира 1 продолжается построение отчета. И во вторую колонку система считывает уже новые данные.
        <br>Итог - отчет построен на основании разных данных.

        <br><br><u>4 эффект: "Фантомы"</u>
        <br>Есть некие данные.
        <br>Кассир 1 строит отчет. Операции идут последовательно для каждой колонки. 
        <br>Система считала данные, записала в первую колонку (например, взяв минимум от них).
        <br>Кассир 2 влез в эту таблицу данных и добавил новые счета/удалил некоторые старые.
        <br>У кассира 1 продолжается построение отчета. И во вторую колонку система считывает уже новые данные.
        <br>Итог — отчет построен на основании разных данных.

        <br><br>Разница между 3-им и 4-ым эффектами в том, что в одном случае данные изменяются, а во втором — добавляются/удаляются. 
        То есть меняется ещё и их количество.

        <br><br><u>Как бороться</u>
        <br>Как бороться с этими проблемами? Нужно изолировать транзакцию. Способов есть несколько, но основные — блокировки и версии.
        <br><br>Блокировки — это когда мы блокируем данные в базе. Можно заблокировать одну строку в таблице, а можно всю таблицу. 
        Можно заблокировать данные на редактирование, а можно и на чтение тоже.
        <br><br>Версии — это когда внутри базы при каждом обновлении создается новая версия данных и сохраняется старая. 
        Версионирование скрыто от разработчика, то есть мы не видим в базе никаких номеров версий и данных по ним. 
        Просто пока транзакция, обновляющая запись, не покомитит свое изменение, остальные потребители читают старую версию записи и не блокируются.

        <h3>Durability — Надёжность</h3>
        Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, 
        что сделанные им изменения не будут отменены из-за какого-либо сбоя. 
        Обесточилась система, произошел сбой в оборудовании? На выполненную транзакцию это не повлияет.
    </p>

    <h2><a name="view">&#10003; Представления, Хранимые процедуры и Триггеры</a></h2>

    <pre>

        -- ПРЕДСТАВЛЕНИЯ

            -- CREATE VIEW ordersProductsCustomers AS
            -- SELECT orders.createdAt AS OrderDAte,
            -- customers.firstName AS Customer,
            -- products.productName AS Product
            -- FROM orders
            -- INNER JOIN products ON orders.productId = products.id
            -- INNER JOIN customers ON orders.customerId = customers.id;

            -- SELECT * FROM  productdb.ordersproductscustomers;
            -- DROP VIEW productdb.ordersproductscustomers; -- удалить

        -- ХРАНИМЫЕ ПРОЦЕДУРЫ

            -- DELIMITER //
            -- CREATE PROCEDURE productdb_GetTable ()
            -- BEGIN
            -- 	SELECT * FROM productdb.orders;
            -- END //
            -- DELIMITER //

            -- CALL productdb_GetTable(); -- вызов хранимой процедуры


            -- CREATE TABLE employees (
            -- id INT AUTO_INCREMENT PRIMARY KEY,
            -- name VARCHAR (50) NOT NULL,
            -- position VARCHAR (50) NOT NULL,
            -- salary DECIMAL(10, 2) NOT NULL,
            -- last_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
            -- );

            -- DELIMITER //
            -- CREATE PROCEDURE productdb.AddEmployee (
            -- IN employeeName VARCHAR (50), 
            -- IN employeePosition VARCHAR (50),
            -- IN employeeSalary DECIMAL(10, 2)
            -- )
            -- BEGIN

            -- INSERT INTO employees(name, position, salary)
            -- VALUES (employeeName, employeePosition, employeeSalary);

            -- -- UPDATE employees 
            -- -- SET last_modified = NOW()
            -- -- WHERE id = LAST_INSERT_ID();

            -- END //
            -- DELIMITER //

            -- CALL productdb.AddEmployee('Иван Грозный', 'Программист', 110000.00);


        -- ТРИГГЕРЫ
            -- BEFORE - срабатывают до выполнения операций, хранимых процедур
            -- ALTER - срабатывают после успешного выполнения операций, хранимых процедур
            -- INSTEAD OFF - перехватывают и заменяют выполнение операции своей логикой
    </pre>
    <p><h3>SQL-представление (SQL view)</h3> 
        Представление — это виртуальная таблица, содержимое которой определяется запросом. 
        Как и таблица, представление состоит из ряда именованных столбцов и строк данных. 
        Пока представление не будет проиндексировано, оно не существует в базе данных как хранимая совокупность значений. 
        Строки и столбцы данных извлекаются из таблиц, указанных в определяющем представление запросе и динамически создаваемых 
        при обращениях к представлению. 
        <br><br>Представление выполняет функцию фильтра базовых таблиц, на которые оно ссылается. 
        Определяющий представление запрос может быть инициирован в одной или нескольких таблицах или в других представлениях текущей или других баз данных. 
        Кроме того, для определения представлений с данными из нескольких разнородных источников можно использовать распределенные запросы. 
        Это полезно, например, если нужно объединить структурированные подобным образом данные, относящиеся к разным серверам, 
        каждый из которых хранит данные конкретного отдела организации.

        <br><br>Представления обычно используются для направления, упрощения и настройки восприятия каждым пользователем информации базы данных. 
        Представления могут использоваться как механизмы безопасности, давая возможность пользователям обращаться к данным через представления, 
        но не предоставляя им разрешений на непосредственный доступ к базовым таблицам, лежащим в основе представлений. 
        Представления могут использоваться для обеспечения интерфейса обратной совместимости, моделирующего таблицу, которая существует, 
        но схема которой изменилась. Представления также можно использовать при копировании данных в SQL Server и из нее для повышения 
        производительности и секционирования данных.
        Представления создаются с помощью операторов SELECT и имеют множество применений:
        <br>
        <br>&#8226; С их помощью можно скрывать от доступа отдельные столбцы или строки. 
        Это механизм безопасности, позволяющий пользователям обращаться к данным через представления, 
        но не предоставляя им разрешений на непосредственный доступ к базовым таблицам.
        
        <br>&#8226; Они позволяют отображать вычисляемые столбцы и скрывать сложные SQL-операторы для упрощения 
        и настройки восприятия информации в базе данных каждым пользователем.
        
        <br>&#8226; Также представления обеспечивают уровень абстракции между данными, обрабатываемыми приложением, и реальными данными, 
        содержащимися в таблицах.

        <br><pre>

            CREATE [ OR ALTER ] VIEW [ schema_name . ] view_name [ (column [ ,...n ] ) ] 
            AS  
            SELECT <select_list1>  FROM T1  
                UNION ALL  
            SELECT <select_list2>  FROM T2  
                UNION ALL  
                ...  
            SELECT <select_listn>  FROM Tn;  
        </pre>
        </p>

        <p><h3>Триггеры</h3> 
            представляют собой методы, с помощью которых можно обеспечивать целостность базы данных даже в том случае, 
            если она используется множеством приложений.
            <br>Триггер - это специальный тип хранимой процедуры, которая автоматически выполняется при каждой попытке изменить защищаемые ей данные. 
            Триггеры обеспечивают целостность данных, предотвращая их несанкционированное или неправильное изменение.
            Допустим, что в базе данных есть таблицы, связанные через поле Stop.Name. Например, это могут быть таблица остановок городского транспорта
            и маршрутов. Разумно определить триггер, который при каждой попытке удалить запись остановки проверит наличие маршрутов, 
            проходящих через эту остановку, и позволит удалить эту запись только при их отсутствии.
            Триггеры не принимают параметров и не возвращают значений. Они выполняются неявно, т
            о есть триггер запускается только при попытке изменения данных.
            <pre>

                CREATE TABLE SalaryUpdates (
                UpdateId INT AUTO_INCREMENT PRIMARY KEY,
                EmployeeId INT, 
                OldSalary DECIMAL(10, 2),
                NewSalary DECIMAL(10, 2),
                UpdateDate DATE
                );

                - DELIMITER //
                CREATE TRIGGER companydb.SalaryUpdateTrigger
                AFTER UPDATE
                ON employees
                FOR EACH ROW
                BEGIN
                    DECLARE Employee_Id INT;
                    SET Employee_Id = @Id;
                    INSERT INTO SalaryUpdates(EmployeeId, OldSalary, NewSalary, UpdateDate)
                    VALUES (Employee_Id, Old.Salary, New.Salary, NOW());
                END//
                DELIMITER //  

                UPDATE employees
                SET Salary = 100500.00
                WHERE Id > 5;

                SELECT * FROM SalaryUpdates;
            </pre>
        </p>

        <p><h3>Хранимые процедуры</h3> 
            - это последовательность компилированных операторов Transact-SQL, хранящихся в системной базе данных SQL Server. 
            Хранимые процедуры предварительно откомпилированы, поэтому эффективность их выполнения выше, чем у обычных запросов. 
            Хранимые процедуры работают непосредственно на сервере и хорошо укладываются в модель клиент - сервер.

            <br><br>Существует два вида хранимых процедур: системные и пользовательские.
            <br>Системные хранимые процедуры предназначены для получения информации из системных таблиц и выполнения различных служебных операций 
            и особенно полезны при администрировании базы данных. Их имена начинаются с <b>sp_ (stored procedure).</b>
            <br>Пользовательские хранимые процедуры создаются непосредственно разработчиками или администраторами базы данных.
            
            <br><br>Полезность хранимых процедур определяется в первую очередь высокой (по сравнению с обычными T-SQL запросами) скоростью их выполнения. 
            Кроме того, они являются средством систематизации часто выполняемых операций.
            
            <br><br>Использование хранимых процедур имеют ряд преимуществ.
            
            <br>1. Хранимые процедуры позволяют выделять правила в отдельную структуру. 
            В дальнейшем эти правила используются многими приложениями, образуя устойчивый к ошибкам интерфейс данных. 
            Выгода такого подхода состоит в том, что можно осуществлять изменение правил только для отдельной части объектов базы данных, 
            а не для всех её приложений.
            
            <br>2. Использование хранимых процедур значительно повышает производительность запросов, 
            однако наибольшей ее прирост достигается при выполнении многократно повторяющихся операций, 
            когда план запроса постоянно хранится в системном кэше.
            
            <br>3. Хранимые процедуры могут принимать аргументы при запуске и возвращать значения (в виде результирующих наборов данных).
            
            <br>4. Хранимые процедуры могут запускаться по расписанию (в режиме автоматического выполнения), задаваемому при запуске SQL Server.
            
            <br>5. Хранимые процедуры используются для извлечения или изменения данных в любое время.
            
            <br>6. Хранимые процедуры, в отличие от триггеров, вызываются явно. То есть при непосредственном обращении к процедуре из приложения, 
            сценария, пакета или задачи.
            
            <br><br>Хранимые процедуры - мощное средство обработки данных. Системные хранимые процедуры играют очень важную роль 
            в администрировании и поддержке базы данных. Пользовательские хранимые процедуры применяются при решении практически любых задач. 
            Кроме того, пользователь может получить право выполнения хранимой процедуры, даже если он не имеет права доступа к объектам, 
            к которым обращается процедура.

            <br><pre>

                CREATE TABLE employees (
                 Id INT AUTO_INCREMENT PRIMARY KEY, 
                 FirstName VARCHAR(50) NOT NULL,
                 LastName VARCHAR(50) NOT NULL, 
                 Age INT, 
                 Salary DECIMAL(10, 2) 
                 );


                - DELIMITER //
                CREATE PROCEDURE companydb.AddEmployee (
                 IN FirstName VARCHAR (50), 
                 IN LastName VARCHAR (50),
                 IN Age INT,
                 IN Salary DECIMAL(10, 2)
                 )
                 BEGIN

                 INSERT INTO employees(FirstName, LastName, Age, Salary)
                 VALUES (FirstName, LastName, Age, Salary);

                 END //
                 DELIMITER //

                 CALL `companydb`.`AddEmployee` ('Igor', 'Van', 32, 87500.00);
                 CALL `companydb`.`AddEmployee` ('Sam', 'Li', 33, 88500.00);
                 CALL `companydb`.`AddEmployee` ('Oleg', 'Oh', 34, 89500.00);
                ...
            </pre>
        </p>



    <h2><a name="opti">Оптимизация запросов</a></h2>

    

</div>

   <footer>
    &copy; 2023 Creative Java cheat sheet :: JAVA&#160;Core
   </footer>
  
</body>
</html>