<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FOR JAVA JUNIOR</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>

   <header>
        <h1>JAVA-DEV</h1>
   </header>

   <nav class="mainNav">
        <a href="#">ООП</a>
        <a href="#">SOLID</a>
        <a href="datastructures.html">Data&#160;structures</a>
        <a href="algorithms.html">Алгоритмы</a>
        <a href="home.html">JAVA&#160;Core</a>
        <a href="#">STREAM&#160;API</a>
        <a href="junit.html">JUnit</a>
        <br>
        <a href="#">HTML5</a>
        <a href="#">Jsoup</a>
        <a href="#">CSS</a>
        <a href="#">JS</a>
        <a href="json.html">JSON</a>
        <a href="http.html">HTTP</a>
        <br>
        <a href="sql.html">SQL</a>
        <a href="maven.html">MAVEN</a>
        <a href="git.html">Git</a>
        <br>
        <a href="spring.html">SPRING</a>
        <a href="#">Docker</a>
        <a href="#">Хэширование</a>
        <a href="#">Patterns</a>
        <a href="#">Микросервисная&#160;архитектура</a>
    </nav>

   <div class="hero">
       <h1>JAVA-DEVOLOPMENT FOR JUNIOR</h1>
       <p>Эта страница создана для помощи в подготовке Junior-разработчика.</p>
       <p>Исключительно для личного пользования.</p>
   </div>

  
    <div class="content">

        <nav>
            <ol class="secondMenu">
                <li><a href = "#jdk"><span>JDK</span></a></li>
                <li><a href = "#mcod"><span>Машинный код и Байт-код</span></a></li>
                <li><a href = "#types"><span>Типы данных</span></a></li>
                <li><a href = "#string"><span>String</span></a></li>
                <li><a href = "#oper"><span>Операторы</span></a></li>
                <li><a href = "#cycles"><span>Циклы и Switсh</span></a></li>
                <li><a href = "#methods"><span>Методы</span></a></li>
                <li><a href = "#classes"><span>Классы, объекты</span></a></li>
                <br>
                <li><a href = "#inter"><span>Интерфейсы и Абстрактные классы</span></a></li>
                <li><a href = "#baseF"><span>Базовые библиотеки и интерфейсы</span></a></li>
                <li><a href = "#static"><span>Static</span></a></li>
                <li><a href = "#object"><span>Object</span></a></li>
                <li><a href = "#inheritance"><span>Наследование</span></a></li>
                <br>
                <li><a href = "#arr"><span>Arrays</span></a></li>
                <li><a href = "#collection"><span>Collection Framework</span></a></li>
                <br>
                <li><a href = "#enum"><span>Enum</span></a></li>
                <li><a href = "#ex"><span>Исключения</span></a></li>
                <li><a href = "#lambda"><span>Лямбда-выражения</span></a></li>
                <br>
                <li><a href = "#threads"><span>Многопоточность</span></a></li>
                <li><a href = "#gc"><span>Garbage collector</span></a></li>
            </ol>
        </nav>
        
        <h2><a name="jdk">JDK</a></h2>

        <h2><a name="mcod">Машинный код и Байт-код</a></h2>
            <div>
                <p>
                    Байтовый код - это промежуточный код между исходным кодом и машинным кодом. Это низкоуровневый код, 
                    который является результатом компиляции исходного кода, написанного на языке высокого уровня. Он обрабатывается виртуальной машиной, 
                    такой как Java Virtual Machine (JVM).
                    <br>Байтовый код - это код, который невозможно запустить после того, как он переведен интерпретатором в машинный код, 
                    тогда он понятен машине. Он скомпилирован для запуска на JVM, и любая система, имеющая JVM, может запускать его независимо 
                    от своей операционной системы. Вот почему Java не зависит от платформы. Байтовый код называется переносимым кодом.
                </p>
                <p>
                    Машинный код представляет собой набор инструкций, понятных непосредственно машине, и обрабатывается центральным процессором (CPU). 
                    Машинный код представлен в двоичном формате (0 и 1), который полностью отличается от байтового кода и исходного кода. 
                    Он рассматривается как представление исходного кода самого низкого уровня. Машинный код получается после компиляции или интерпретации. 
                    Его также называют машинным языком.
                </p>
                <img src="images/machinecode.png"></img>
                <table>
                    <br><br><span>Разница между байтовым кодом и машинным кодом:</span>
                    <thead>
                        <tr>
                          <th>N</th>
                          <th style="width: 48%;">Байтовый код</th>
                          <th style="width: 48%;">Машинный код</th>
                        </tr>
                      </thead>

                      <tbody>
                        <tr>
                          <td>01</td>
                          <td>Байтовый код, состоящий из двоичных, шестнадцатеричных макрокоманд, таких как (создать, добавить, поменять местами и т.д.), 
                            И он не понятен процессору напрямую. Он предназначен для эффективного выполнения программным обеспечением, 
                            таким как виртуальная машина. Промежуточный уровень.</td>
                          <td>Машинный код, состоящий из двоичных инструкций, которые непосредственно понятны центральному процессору.</td>
                        </tr>
                        <tr>
                          <td>02</td>
                          <td>Байтовый код рассматривается как код среднего уровня.</td>
                          <td>Машинный код рассматривается как низкоуровневый код.</td>
                        </tr>
                        <tr>
                          <td>03</td>
                          <td>Байтовый код - это неисполнимый код, сгенерированный после компиляции исходного кода, 
                            и для его выполнения требуется интерпретатор.</td>
                          <td>Машинный код - это набор инструкций на машинном языке или в двоичном формате, 
                            который выполняется непосредственно процессором.</td>
                        </tr>
                        <tr>
                            <td>04</td>
                            <td>Байтовый код выполняется виртуальной машиной, а затем центральным процессором.</td>
                            <td>Машинный код не выполняется виртуальной машиной, он выполняется непосредственно процессором.</td>
                          </tr>
                        <tr>
                            <td>05</td>
                            <td>Байтовый код менее специфичен для машины, чем машинный код.</td>
                            <td>Машинный код более специфичен для машины, чем байтовый код.</td>
                        </tr>
                        <tr>
                            <td>06</td>
                            <td>Он не зависит от платформы, поскольку зависит от виртуальной машины, а система, имеющая виртуальную машину, 
                                может выполняться независимо от платформы.</td>
                            <td>Он не зависит от платформы, поскольку объектный код одной платформы не может быть запущен в одной и той же 
                                операционной системе. Объект варьируется в зависимости от архитектуры системы и собственных инструкций, 
                                связанных с машиной.</td>
                          </tr>
                        <tr>
                            <td>07</td>
                            <td>Весь исходный код не обязательно преобразовывать в байтовый код для выполнения процессором. 
                                Некоторый исходный код, написанный каким-либо конкретным языком высокого уровня, преобразуется в байтовый код, 
                                а затем байтовый код в объектный код для выполнения процессором.</td>
                            <td>Весь исходный код должен быть преобразован в машинный код перед его выполнением центральным процессором.</td>
                        </tr>
                      </tbody>
                </table>
            </div>

        <h2><a name="types">ТИПЫ ДАННЫХ</a></h2>
        <h2><a name="string">STRING</a></h2>
        <h2><a name="oper">ОПЕРАТОРЫ</a></h2>
        <h2><a name="cycles">ЦИКЛЫ и SWITCH CASE</a></h2>
        <h2><a name="methods">МЕТОДЫ</a></h2>
        <h2><a name="classes">КЛАССЫ и ОБЪЕКТЫ</a></h2>


        <h2><a name="inter">&#10003; ИНТЕРФЕЙСЫ и АБСТРАКТЫЕ КЛАССЫ</a></h2>

            <div>
                <p>
                    <h3>Интерфейсы</h3>
                    Интерфейс — это контракт, который должен быть реализован конкретным классом. 
                    У интерфейса не может быть состояния, поэтому в нем нельзя использовать изменяемые поля экземпляра. 
                    В интерфейсе могут быть только неизменяемые final-поля.
                    <br>Если вы заметили, что ряд ваших классов содержит одинаковые методы, но с разными реализациями, 
                    то стоит использовать интерфейс. Методы интерфейса неявно абстрактны ( их не нужно явно объявлять как abstract) 
                    и обязаны быть реализованы в классе, 
                    реализующем этот интерфейс.
                    <br><br>Интерфейс определяет поведение, в общем смысле интерфейс рассказывает о том, как работать с классом, 
                    который этот интерфейс реализует, к примеру все двери умеют закрываться и открываться и на не важно какая это дверь 
                    и как она сделана, главное, что это дверь и у неё есть наличие методов для открытия и закрытия. 
                    Интерфейс может использоваться классами, которые вообще никак не связаны с друг другом по смыслу (Comparable как пример). 
                    И самое важное множественное наследование.
                    <br><br>Default-методы : После появления в Java 8 методов по умолчанию, некоторые разработчики решили, 
                    что интерфейсы стали абстрактными классами. Однако это не так, поскольку у интерфейсов не может быть состояния.
                    У методов по умолчанию может быть реализация, а у абстрактных методов — нет. Методы по умолчанию — результат появления 
                    лямбда-выражений и Stream API. Важно отметить, что у default-метода должна быть реализация и default-метод не может быть статическим.

                    <h3>Абстрактные классы</h3>
                    У абстрактных классов может быть состояние в виде изменяемых полей экземпляра. Аналогично интерфейсам в абстрактных классах 
                    могут быть абстрактные методы. Абстрактный метод — это метод без тела (без реализации). 
                    Но в отличие от интерфейсов, абстрактные методы в абстрактных классах должны быть явно объявлены как абстрактные. 
                    Рекомендуется использовать абстрактный класс, когда вам нужно изменяемое состояние.
                    Если хранить состояние класса не нужно, обычно лучше использовать интерфейс.
                    <br><br>Абстрактный класс определяет поведение и состояние. Абстрактный класс используют для наследования 
                    (т.е. мы имеем тесную связь между классами), с помощью него описывают общие черты для наследников. 
                    В нем могут находится конкретные (в интерфейсе тоже с java 8) и статические методы.

                    <br><br>
                    <h3>10 вопросов по абстрактным классам и интерфейсам :</h3>

                    <h4><b><u>1. Могут ли в языке Java у абстрактного класса быть конструкторы?</b></u></h4>
                    Да, в абстрактном классе в Java можно объявить и определить конструкторы. 
                    Поскольку создавать экземпляры абстрактных классов нельзя, вызвать такой конструктор можно только при формировании цепочки конструкторов, 
                    то есть при создании экземпляра конкретного класса-реализации.
                    <br>А какой смысл в конструкторе, если создать экземпляр абстрактного класса все равно нельзя? 
                    Дело в том, что его всё равно можно использовать для задания начальных значений общих переменных, 
                    объявленных в абстрактном классе и используемых различными реализациями.
                    Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов. 
                    Без него ваш подкласс не скомпилируется, поскольку первый оператор в любом конструкторе представляет собой неявный вызов super() 
                    – конструктора суперкласса по умолчанию в языке Java.

                    <h4><b><u>2. Могут ли абстрактные классы в языке Java реализовывать интерфейсы? 
                        Должны ли они реализовывать все методы?</u></b></h4>
                    Да, абстрактные классы могут реализовывать интерфейсы с помощью ключевого слова <i>implements.</i> 
                    Поскольку они абстрактные, то не обязаны реализовывать все методы. 
                    Наличие абстрактного базового класса и интерфейса для объявления типа является рекомендуемой практикой.
                    
                    <br><br>Пример — интерфейс java.util.List и соответствующий абстрактный класс java.util.AbstractList. 
                    Поскольку AbstractList реализует все общие методы, то конкретные реализации (например, LinkedList и ArrayList) 
                    не должны реализовать все методы, как в случае, если бы они реализовали интерфейс List напрямую. 
                    <br>Это решение сочетает преимущество использования интерфейса для объявления типа 
                    и гибкость абстрактного класса для реализации всего общего поведения в одном месте.
                    
                    <h4><b><u>3. Может ли абстрактный класс быть final?</u></b></h4>
                    Нет, не может. Ключевое слово final означает, что класс на вершине иерархии, и у него не может быть наследников. 
                    А абстрактный класс без наследников — это сферический конь в вакууме, так как нельзя создать экземпляр abstract class.
                    Таким образом, если класс одновременно abstract и final, то у него нет наследников и нельзя создать его экземпляр.
                    <br>Компилятор Java выдаст ошибку, если сделать класс одновременно abstract и final.

                    <h4><b><u>4. Могут ли у абстрактного класса в языке Java быть статические методы?</u></b></h4>
                    Да, абстрактные классы могут объявлять и определять статические методы. 
                    Только необходимо следовать общим принципам создания статических методов в Java, поскольку они нежелательны 
                    при объектно-ориентированном проектировании, ведь переопределение статических методов в Java невозможно. 
                    Статические методы в абстрактном классе – явление очень редкое, но, если на это есть уважительные причины, 
                    вам ничего не помешает их использовать.

                    <h4><b><u>5. Можно ли создать экземпляр абстрактного класса?</u></b></h4>
                    Нет, этого делать нельзя. Суть абстрактного класса заключается в том, что он не завершён, и его нужно завершить в классах-наследниках. 
                    То есть этот класс не готов к использованию. В нём, например, может отсутствовать реализация каких-то методов. 
                    Раз класс не готов к использованию, то нельзя создавать его объект. А вот экземпляры наследников абстрактного класса создавать можно.     
                    <br>Компилятор Java выдаст ошибку, если программа попытается создать экземпляр абстрактного класса.

                    <h4><b><u>6. Обязательно ли в абстрактном классе должны быть абстрактные методы?</u></b></h4>
                    Нет, в абстрактном классе может не быть ни одного абстрактного метода. 
                    Сделать класс абстрактным в языке Java можно просто путем использования ключевого слова abstract при объявлении. 
                    Компилятор обеспечит выполнение всех структурных ограничений, например, запрета на создание экземпляров этого класса. 
                    Кстати, вопрос о том, должны ли быть абстрактные методы в абстрактном классе или интерфейсе – спорный. 
                    Мне представляется, что в абстрактном классе должны быть абстрактные методы, поскольку это первое, о чем думает программист, 
                    видя абстрактный класс. Это хорошо согласуется с принципом минимизации неожиданностей.

                    <h4><b><u>7. Каковы различия между абстрактным классом и интерфейсом в Java?</u></b></h4>
                    Это важнейший и один из самых классических вопросов на собеседованиях по языку Java. Я не могу сосчитать, сколько раз встречал этот вопрос на собеседованиях по Java для всех уровней. 
                    Интересным этот вопрос делает, в частности, возможность для соискателя представить пример. Отвечать на вопросы по основам объектно-ориентированного программирования, например, рассказать об абстракции, инкапсуляции, полиморфизме и наследовании, легко, но, когда дело доходит до подобных тонких нюансов, претенденты на должность очень часто теряются и говорят, что первое приходит в голову.

                    Ответ на этот вопрос тянет на отдельную статью (особенно после изменений в Java 8), тем не менее, если кратко:
                    Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме public static final), в то время как у абстрактного класса они могут быть.

                    Абстрактный класс наследуется (extends), а интерфейс — реализуется (implements). Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.

                    Абстрактные классы используются, когда есть отношение "is-a", то есть класс-наследник расширяет базовый абстрактный класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.
                    
                    <h4><b><u>8. Когда имеет смысл предпочесть абстрактный класс интерфейсу и наоборот?</u></b></h4>
                    Это продолжение предыдущих вопросов по абстрактным классам и интерфейсам. Если вы знаете, каковы их синтаксические различия, то ответ на этот вопрос не доставит вам проблем, так как именно они служат определяющим фактором принятия решения. Поскольку в опубликованный интерфейс практически невозможно добавить новый метод, в случае потенциальной необходимости доработки лучше использовать абстрактный класс. Развивать абстрактные классы в Java проще, чем интерфейсы. Аналогично, если в интерфейсе слишком много методов и реализация их всех становится настоящей головной болью, лучше создать абстрактный класс для реализации по умолчанию. Этому паттерну следуют и в пакете коллекций Java, абстрактный класс AbstractList обеспечивает реализацию по умолчанию для интерфейса List.

                    Используйте абстрактные классы, если:
                    Вы хотите поделиться кодом между несколькими тесно связанными классами.

                    Вы ожидаете, что классы, которые расширяют ваш абстрактный класс, имеют много общих методов или полей, или требуют других модификаторов доступа, кроме public (например, protected и private).

                    Вы хотите объявить нестатические или не-final поля. Это позволяет вам определять методы, которые могут получить доступ и изменить состояние объекта, которому они принадлежат.
                    Используйте интерфейсы, если:
                    Вы ожидаете, что несвязанные классы будут реализовывать ваш интерфейс. Например, интерфейсы Comparable и Cloneable реализуются многими несвязанными классами.

                    Вы хотите определить поведение конкретного типа данных, но вам не важно, кто его реализует.

                    Вы хотите использовать множественное наследование типа.
                    <h4><b><u>9. Что такое абстрактный метод в языке Java?</u></b></h4>
                    Абстрактный метод – это метод без тела. Вы просто объявляете метод, не определяя его, с использованием ключевого слова abstract в объявлении метода. Все объявленные внутри интерфейса в языке Java методы – по умолчанию абстрактные. Вот пример абстрактного метода в языке Java:

                    public void abstract printVersion();

                    Теперь, для реализации этого метода необходимо расширить абстрактный класс и этот метод переопределить.

                    <h4><b><u>10. Может ли абстрактный класс в Java содержать метод main?</u></b></h4>
                    Да, абстрактный класс в Java может содержать метод main, ведь это просто еще один статический метод, 
                    и абстрактный класс можно выполнять при помощи метода main, если не создавать его экземпляров.

                    <br><br>
                    <h3>Различия между абстрактными классами и интерфейсами</h3>
                    С точки зрения объектно-ориентированного программирования основное различие между интерфейсом и абстрактным классом заключается в том, 
                    что интерфейс не может иметь состояния, тогда как абстрактный класс может (в виде полей экземпляра).
                    <br>Другое ключевое различие заключается в том, что классы могут реализовывать более одного интерфейса, 
                    но расширять только один абстрактный класс. Множественное наследование может привести к тупиковым ситуациям в коде, 
                    поэтому авторы Java решили этого избежать, отказавшись от него.
                    <br>Еще одно различие состоит в том, что интерфейс может быть реализован классом или расширен другим интерфейсом, 
                    а класс может быть только расширен.
                    <br>Также важно отметить, что лямбда-выражения могут использоваться только с функциональными интерфейсами (интерфейс только с одним методом), 
                    но не с абстрактными классами с одним абстрактным методом.
                </p>

                <img src="images/interfaceVSac.png"></img>

            </div>

        <h2><a name="baseF">БАЗОВЫЕ БИБЛИОТЕКТИ и ИНТЕРФЕЙСЫ</a></h2>

        <h2><a name="static">STATIC</a></h2>
        <h2><a name="object">OBJECT</a></h2>
        <h2><a name="inheritance">НАСЛЕДОВАНИЕ</a></h2>
        
        <h2><a name="arr">ARRAYS</a></h2>

        <h2><a name="collection">COLLECTION FRAMEWORK</a></h2>



        
        
        <h2><a name="enum">ENUM</a></h2>
        <h2><a name="ex">ИСКЛЮЧЕНИЯ</a></h2>
        <h2><a name="lambda">ЛЯМБДА-ВЫРАЖЕНИЯ</a></h2>
        

        <h2><a name="threads">МНОГОПОТОЧНОСТЬ</a></h2>
        <h2><a name="gc">GARBAGE COLLECTOR</a></h2>

    </div>

   <footer>
    &copy; 2023 Creative Java cheat sheet :: JAVA&#160;Core
   </footer>
  
</body>
</html>